[
  [
    {
      "id": "1. Two Sum",
      "code": "class Solution:\n  def twoSum(self, nums: List[int], target: int) -> List[int]:\n    numToIndex = {}\n\n    for i, num in enumerate(nums):\n      if target - num in numToIndex:\n        return numToIndex[target - num], i\n      numToIndex[num] = i\n"
    }
  ],
  [
    {
      "id": "2. Add Two Numbers",
      "code": "class Solution:\n  def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n    dummy = ListNode(0)\n    curr = dummy\n    carry = 0\n\n    while carry or l1 or l2:\n      if l1:\n        carry += l1.val\n        l1 = l1.next\n      if l2:\n        carry += l2.val\n        l2 = l2.next\n      curr.next = ListNode(carry % 10)\n      carry //= 10\n      curr = curr.next\n\n    return dummy.next\n"
    }
  ],
  [
    {
      "id": "3. Longest Substring Without Repeating Characters",
      "code": "class Solution:\n  def lengthOfLongestSubstring(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      while count[c] > 1:\n        count[s[l]] -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "4. Median of Two Sorted Arrays",
      "code": "class Solution:\n  def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n    n1 = len(nums1)\n    n2 = len(nums2)\n    if n1 > n2:\n      return self.findMedianSortedArrays(nums2, nums1)\n\n    l = 0\n    r = n1\n\n    while l <= r:\n      partition1 = (l + r) // 2\n      partition2 = (n1 + n2 + 1) // 2 - partition1\n      maxLeft1 = -2**31 if partition1 == 0 else nums1[partition1 - 1]\n      maxLeft2 = -2**31 if partition2 == 0 else nums2[partition2 - 1]\n      minRight1 = 2**31 - 1 if partition1 == n1 else nums1[partition1]\n      minRight2 = 2**31 - 1 if partition2 == n2 else nums2[partition2]\n      if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n        return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5 if (n1 + n2) % 2 == 0 else max(maxLeft1, maxLeft2)\n      elif maxLeft1 > minRight2:\n        r = partition1 - 1\n      else:\n        l = partition1 + 1\n"
    }
  ],
  [
    {
      "id": "5. Longest Palindromic Substring",
      "code": "class Solution:\n  def longestPalindrome(self, s: str) -> str:\n    if not s:\n      return ''\n\n    indices = [0, 0]\n\n    # Returns [start, end] indices of the longest palindrome extended from s[i..j]\n    def extend(s: str, i: int, j: int) -> Tuple[int, int]:\n      while i >= 0 and j < len(s):\n        if s[i] != s[j]:\n          break\n        i -= 1\n        j += 1\n      return i + 1, j - 1\n\n    for i in range(len(s)):\n      l1, r1 = extend(s, i, i)\n      if r1 - l1 > indices[1] - indices[0]:\n        indices = l1, r1\n      if i + 1 < len(s) and s[i] == s[i + 1]:\n        l2, r2 = extend(s, i, i + 1)\n        if r2 - l2 > indices[1] - indices[0]:\n          indices = l2, r2\n\n    return s[indices[0]:indices[1] + 1]\n"
    }
  ],
  [
    {
      "id": "6. Zigzag Conversion",
      "code": "class Solution:\n  def convert(self, s: str, numRows: int) -> str:\n    rows = [''] * numRows\n    k = 0\n    direction = (numRows == 1) - 1\n\n    for c in s:\n      rows[k] += c\n      if k == 0 or k == numRows - 1:\n        direction *= -1\n      k += direction\n\n    return ''.join(rows)\n"
    }
  ],
  [
    {
      "id": "7. Reverse Integer",
      "code": "class Solution:\n  def reverse(self, x: int) -> int:\n    ans = 0\n    sign = -1 if x < 0 else 1\n    x *= sign\n\n    while x:\n      ans = ans * 10 + x % 10\n      x //= 10\n\n    return 0 if ans < -2**31 or ans > 2**31 - 1 else sign * ans\n"
    }
  ],
  [
    {
      "id": "8. String to Integer (atoi)",
      "code": "class Solution:\n  def myAtoi(self, s: str) -> int:\n    s = s.strip()\n    if not s:\n      return 0\n\n    sign = -1 if s[0] == '-' else 1\n    if s[0] in {'-', '+'}:\n      s = s[1:]\n\n    num = 0\n\n    for c in s:\n      if not c.isdigit():\n        break\n      num = num * 10 + ord(c) - ord('0')\n      if sign * num <= -2**31:\n        return -2**31\n      if sign * num >= 2**31 - 1:\n        return 2**31 - 1\n\n    return sign * num\n"
    }
  ],
  [
    {
      "id": "9. Palindrome Number",
      "code": "class Solution:\n  def isPalindrome(self, x: int) -> bool:\n    if x < 0:\n      return False\n\n    rev = 0\n    y = x\n\n    while y:\n      rev = rev * 10 + y % 10\n      y //= 10\n\n    return rev == x\n"
    }
  ],
  [
    {
      "id": "10. Regular Expression Matching",
      "code": "class Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    # dp[i][j] := True if s[0..i) matches p[0..j)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return j >= 0 and p[j] == '.' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*' and dp[0][j - 1]:\n        dp[0][j + 1] = True\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          noRepeat = dp[i + 1][j - 1]  # Min index of '*' is 1\n          doRepeat = isMatch(i, j - 1) and dp[i][j + 1]\n          dp[i + 1][j + 1] = noRepeat or doRepeat\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]\n"
    }
  ],
  [
    {
      "id": "11. Container With Most Water",
      "code": "class Solution:\n  def maxArea(self, height: List[int]) -> int:\n    ans = 0\n    l = 0\n    r = len(height) - 1\n\n    while l < r:\n      minHeight = min(height[l], height[r])\n      ans = max(ans, minHeight * (r - l))\n      if height[l] < height[r]:\n        l += 1\n      else:\n        r -= 1\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "12. Integer to Roman",
      "code": "class Solution:\n  def intToRoman(self, num: int) -> str:\n    valueSymbols = [(1000, 'M'), (900, 'CM'),\n                    (500, 'D'), (400, 'CD'),\n                    (100, 'C'), (90, 'XC'),\n                    (50, 'L'), (40, 'XL'),\n                    (10, 'X'), (9, 'IX'),\n                    (5, 'V'), (4, 'IV'),\n                    (1, 'I')]\n    ans = []\n\n    for value, symbol in valueSymbols:\n      if num == 0:\n        break\n      count, num = divmod(num, value)\n      ans.append(symbol * count)\n\n    return ''.join(ans)\n"
    }
  ],
  [
    {
      "id": "13. Roman to Integer",
      "code": "class Solution:\n  def romanToInt(self, s: str) -> int:\n    ans = 0\n    roman = {'I': 1, 'V': 5, 'X': 10, 'L': 50,\n             'C': 100, 'D': 500, 'M': 1000}\n\n    for a, b in zip(s, s[1:]):\n      if roman[a] < roman[b]:\n        ans -= roman[a]\n      else:\n        ans += roman[a]\n\n    return ans + roman[s[-1]]\n"
    }
  ],
  [
    {
      "id": "14. Longest Common Prefix",
      "code": "class Solution:\n  def longestCommonPrefix(self, strs: List[str]) -> str:\n    if not strs:\n      return ''\n\n    for i in range(len(strs[0])):\n      for j in range(1, len(strs)):\n        if i == len(strs[j]) or strs[j][i] != strs[0][i]:\n          return strs[0][:i]\n\n    return strs[0]\n"
    }
  ],
  [
    {
      "id": "15. 3Sum",
      "code": "class Solution:\n  def threeSum(self, nums: List[int]) -> List[List[int]]:\n    if len(nums) < 3:\n      return []\n\n    ans = []\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n      if i > 0 and nums[i] == nums[i - 1]:\n        continue\n      l = i + 1\n      r = len(nums) - 1\n      while l < r:\n        summ = nums[i] + nums[l] + nums[r]\n        if summ == 0:\n          ans.append((nums[i], nums[l], nums[r]))\n          l += 1\n          r -= 1\n          while nums[l] == nums[l - 1] and l < r:\n            l += 1\n          while nums[r] == nums[r + 1] and l < r:\n            r -= 1\n        elif summ < 0:\n          l += 1\n        else:\n          r -= 1\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "16. 3Sum Closest",
      "code": "class Solution:\n  def threeSumClosest(self, nums: List[int], target: int) -> int:\n    ans = nums[0] + nums[1] + nums[2]\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n      if i > 0 and nums[i] == nums[i - 1]:\n        continue\n      l = i + 1\n      r = len(nums) - 1\n      while l < r:\n        summ = nums[i] + nums[l] + nums[r]\n        if summ == target:\n          return summ\n        if abs(summ - target) < abs(ans - target):\n          ans = summ\n        if summ < target:\n          l += 1\n        else:\n          r -= 1\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "17. Letter Combinations of a Phone Number",
      "code": "class Solution:\n  def letterCombinations(self, digits: str) -> List[str]:\n    if not digits:\n      return []\n\n    digitToLetters = ['', '', 'abc', 'def', 'ghi',\n                      'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']\n    ans = []\n\n    def dfs(i: int, path: List[chr]) -> None:\n      if i == len(digits):\n        ans.append(''.join(path))\n        return\n\n      for letter in digitToLetters[ord(digits[i]) - ord('0')]:\n        path.append(letter)\n        dfs(i + 1, path)\n        path.pop()\n\n    dfs(0, [])\n    return ans\n"
    }
  ],
  [
    {
      "id": "18. 4Sum",
      "code": "class Solution:\n  def fourSum(self, nums: List[int], target: int):\n    ans = []\n\n    def nSum(l: int, r: int, target: int, n: int, path: List[int], ans: List[List[int]]) -> None:\n      if r - l + 1 < n or n < 2 or target < nums[l] * n or target > nums[r] * n:\n        return\n      if n == 2:\n        while l < r:\n          summ = nums[l] + nums[r]\n          if summ == target:\n            ans.append(path + [nums[l], nums[r]])\n            l += 1\n            while nums[l] == nums[l - 1] and l < r:\n              l += 1\n          elif summ < target:\n            l += 1\n          else:\n            r -= 1\n        return\n\n      for i in range(l, r + 1):\n        if i > l and nums[i] == nums[i - 1]:\n          continue\n\n        nSum(i + 1, r, target - nums[i], n - 1, path + [nums[i]], ans)\n\n    nums.sort()\n    nSum(0, len(nums) - 1, target, 4, [], ans)\n    return ans\n"
    }
  ],
  [
    {
      "id": "19. Remove Nth Node From End of List",
      "code": "class Solution:\n  def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n    slow = head\n    fast = head\n\n    for _ in range(n):\n      fast = fast.next\n    if not fast:\n      return head.next\n\n    while fast.next:\n      slow = slow.next\n      fast = fast.next\n    slow.next = slow.next.next\n\n    return head\n"
    }
  ],
  [
    {
      "id": "20. Valid Parentheses",
      "code": "class Solution:\n  def isValid(self, s: str) -> bool:\n    stack = []\n\n    for c in s:\n      if c == '(':\n        stack.append(')')\n      elif c == '{':\n        stack.append('}')\n      elif c == '[':\n        stack.append(']')\n      elif not stack or stack.pop() != c:\n        return False\n\n    return not stack\n"
    }
  ],
  [
    {
      "id": "21. Merge Two Sorted Lists",
      "code": "class Solution:\n  def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n    if not list1 or not list2:\n      return list1 if list1 else list2\n    if list1.val > list2.val:\n      list1, list2 = list2, list1\n    list1.next = self.mergeTwoLists(list1.next, list2)\n    return list1\n"
    }
  ],
  [
    {
      "id": "22. Generate Parentheses",
      "code": "class Solution:\n  def generateParenthesis(self, n):\n    ans = []\n\n    def dfs(l: int, r: int, s: str) -> None:\n      if l == 0 and r == 0:\n        ans.append(s)\n      if l > 0:\n        dfs(l - 1, r, s + '(')\n      if l < r:\n        dfs(l, r - 1, s + ')')\n\n    dfs(n, n, '')\n    return ans\n"
    }
  ],
  [
    {
      "id": "23. Merge k Sorted Lists",
      "code": "from queue import PriorityQueue\n\n\n class Solution:\n  def mergeKLists(self, lists: List[ListNode]) -> ListNode:\n    dummy = ListNode(0)\n    curr = dummy\n    pq = PriorityQueue()\n\n    for i, lst in enumerate(lists):\n      if lst:\n        pq.put((lst.val, i, lst))\n\n    while not pq.empty():\n      _, i, minNode = pq.get()\n      if minNode.next:\n        pq.put((minNode.next.val, i, minNode.next))\n      curr.next = minNode\n      curr = curr.next\n\n    return dummy.next\n"
    }
  ],
  [
    {
      "id": "24. Swap Nodes in Pairs",
      "code": "class Solution:\n  def swapPairs(self, head: ListNode) -> ListNode:\n    def getLength(head: ListNode) -> int:\n      length = 0\n      while head:\n        length += 1\n        head = head.next\n      return length\n\n    length = getLength(head)\n    dummy = ListNode(0, head)\n    prev = dummy\n    curr = head\n\n    for _ in range(length // 2):\n      next = curr.next\n      curr.next = next.next\n      next.next = prev.next\n      prev.next = next\n      prev = curr\n      curr = curr.next\n\n    return dummy.next\n"
    }
  ],
  [
    {
      "id": "25. Reverse Nodes in k-Group",
      "code": "class Solution:\n  def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n    if not head:\n      return None\n\n    tail = head\n\n    for _ in range(k):\n      if not tail:  # Less than k nodes, do nothing\n        return head\n      tail = tail.next\n\n    newHead = self._reverse(head, tail)\n    head.next = self.reverseKGroup(tail, k)\n    return newHead\n\n  # Reverses [head, tail)\n  def _reverse(self, head: Optional[ListNode], tail: Optional[ListNode]) -> Optional[ListNode]:\n    prev = None\n    curr = head\n\n    while curr != tail:\n      next = curr.next\n      curr.next = prev\n      prev = curr\n      curr = next\n\n    return prev\n"
    }
  ],
  [
    {
      "id": "26. Remove Duplicates from Sorted Array",
      "code": "class Solution:\n  def removeDuplicates(self, nums: List[int]) -> int:\n    i = 0\n\n    for num in nums:\n      if i < 1 or num > nums[i - 1]:\n        nums[i] = num\n        i += 1\n\n    return i\n"
    }
  ],
  [
    {
      "id": "27. Remove Element",
      "code": "class Solution:\n  def removeElement(self, nums: List[int], val: int) -> int:\n    i = 0\n\n    for num in nums:\n      if num != val:\n        nums[i] = num\n        i += 1\n\n    return i\n"
    }
  ],
  [
    {
      "id": "28. Find the Index of the First Occurrence in a String",
      "code": "class Solution:\n  def strStr(self, haystack: str, needle: str) -> int:\n    m = len(haystack)\n    n = len(needle)\n\n    for i in range(m - n + 1):\n      if haystack[i:i + n] == needle:\n        return i\n\n    return -1\n"
    }
  ],
  [
    {
      "id": "29. Divide Two Integers",
      "code": "class Solution:\n  def divide(self, dividend: int, divisor: int) -> int:\n    if dividend == -2**31 and divisor == -1:\n      return 2**31 - 1\n\n    sign = -1 if (dividend > 0) ^ (divisor > 0) else 1\n    ans = 0\n    dvd = abs(dividend)\n    dvs = abs(divisor)\n\n    while dvd >= dvs:\n      k = 1\n      while k * 2 * dvs <= dvd:\n        k <<= 1\n      dvd -= k * dvs\n      ans += k\n\n    return sign * ans\n"
    }
  ],
  [
    {
      "id": "30. Substring with Concatenation of All Words",
      "code": "class Solution:\n  def findSubstring(self, s: str, words: List[str]) -> List[int]:\n    if len(s) == 0 or words == []:\n      return []\n\n    k = len(words)\n    n = len(words[0])\n    ans = []\n    count = collections.Counter(words)\n\n    for i in range(len(s) - k * n + 1):\n      seen = collections.defaultdict(int)\n      j = 0\n      while j < k:\n        word = s[i + j * n: i + j * n + n]\n        seen[word] += 1\n        if seen[word] > count[word]:\n          break\n        j += 1\n      if j == k:\n        ans.append(i)\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "31. Next Permutation",
      "code": "class Solution:\n  def nextPermutation(self, nums: List[int]) -> None:\n    n = len(nums)\n\n    # From back to front, find the first num < nums[i + 1]\n    i = n - 2\n    while i >= 0:\n      if nums[i] < nums[i + 1]:\n        break\n      i -= 1\n\n    # From back to front, find the first num > nums[i], swap it with nums[i]\n    if i >= 0:\n      for j in range(n - 1, i, -1):\n        if nums[j] > nums[i]:\n          nums[i], nums[j] = nums[j], nums[i]\n          break\n\n    def reverse(nums: List[int], l: int, r: int) -> None:\n      while l < r:\n        nums[l], nums[r] = nums[r], nums[l]\n        l += 1\n        r -= 1\n\n    # Reverse nums[i + 1..n - 1]\n    reverse(nums, i + 1, len(nums) - 1)\n"
    }
  ],
  [
    {
      "id": "32. Longest Valid Parentheses",
      "code": "class Solution:\n  def longestValidParentheses(self, s: str) -> int:\n    s2 = ')' + s\n    # dp[i] := Length of longest valid parentheses substring of s2[1..i]\n    dp = [0] * len(s2)\n\n    for i in range(1, len(s2)):\n      if s2[i] == ')' and s2[i - dp[i - 1] - 1] == '(':\n        dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2\n\n    return max(dp)\n"
    }
  ],
  [
    {
      "id": "33. Search in Rotated Sorted Array",
      "code": "class Solution:\n  def search(self, nums: List[int], target: int) -> int:\n    l = 0\n    r = len(nums) - 1\n\n    while l <= r:\n      m = (l + r) // 2\n      if nums[m] == target:\n        return m\n      if nums[l] <= nums[m]:  # nums[l..m] are sorted\n        if nums[l] <= target < nums[m]:\n          r = m - 1\n        else:\n          l = m + 1\n      else:  # nums[m..n - 1] are sorted\n        if nums[m] < target <= nums[r]:\n          l = m + 1\n        else:\n          r = m - 1\n\n    return -1\n"
    }
  ],
  [
    {
      "id": "34. Find First and Last Position of Element in Sorted Array",
      "code": "class Solution:\n  def searchRange(self, nums: List[int], target: int) -> List[int]:\n    l = bisect_left(nums, target)\n    if l == len(nums) or nums[l] != target:\n      return -1, -1\n    r = bisect_right(nums, target) - 1\n    return l, r\n"
    }
  ],
  [
    {
      "id": "35. Search Insert Position",
      "code": "class Solution:\n  def searchInsert(self, nums: List[int], target: int) -> int:\n    l = 0\n    r = len(nums)\n\n    while l < r:\n      m = (l + r) // 2\n      if nums[m] == target:\n        return m\n      if nums[m] < target:\n        l = m + 1\n      else:\n        r = m\n\n    return l\n"
    }
  ],
  [
    {
      "id": "36. Valid Sudoku",
      "code": "class Solution:\n  def isValidSudoku(self, board: List[List[str]]) -> bool:\n    seen = set()\n\n    for i in range(9):\n      for j in range(9):\n        c = board[i][j]\n        if c == '.':\n          continue\n        if c + '@row ' + str(i) in seen or \\\n           c + '@col ' + str(j) in seen or \\\n           c + '@box ' + str(i // 3) + str(j // 3) in seen:\n          return False\n        seen.add(c + '@row ' + str(i))\n        seen.add(c + '@col ' + str(j))\n        seen.add(c + '@box ' + str(i // 3) + str(j // 3))\n\n    return True\n"
    }
  ],
  [
    {
      "id": "37. Sudoku Solver",
      "code": "class Solution:\n  def solveSudoku(self, board: List[List[str]]) -> None:\n    def isValid(row: int, col: int, c: chr) -> bool:\n      for i in range(9):\n        if board[i][col] == c or \\\n           board[row][i] == c or \\\n           board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == c:\n          return False\n      return True\n\n    def solve(s: int) -> bool:\n      if s == 81:\n        return True\n\n      i = s // 9\n      j = s % 9\n\n      if board[i][j] != '.':\n        return solve(s + 1)\n\n      for c in string.digits[1:]:\n        if isValid(i, j, c):\n          board[i][j] = c\n          if solve(s + 1):\n            return True\n          board[i][j] = '.'\n\n      return False\n\n    solve(0)\n"
    }
  ],
  [
    {
      "id": "38. Count and Say",
      "code": "class Solution:\n  def countAndSay(self, n: int) -> str:\n    ans = '1'\n\n    for _ in range(n - 1):\n      nxt = ''\n      i = 0\n      while i < len(ans):\n        count = 1\n        while i + 1 < len(ans) and ans[i] == ans[i + 1]:\n          count += 1\n          i += 1\n        nxt += str(count) + ans[i]\n        i += 1\n      ans = nxt\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "39. Combination Sum",
      "code": "class Solution:\n  def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n    ans = []\n\n    def dfs(s: int, target: int, path: List[int]) -> None:\n      if target < 0:\n        return\n      if target == 0:\n        ans.append(path.clone())\n        return\n\n      for i in range(s, len(candidates)):\n        path.append(candidates[i])\n        dfs(i, target - candidates[i], path)\n        path.pop()\n\n    candidates.sort()\n    dfs(0, target, [])\n    return ans\n"
    }
  ],
  [
    {
      "id": "40. Combination Sum II",
      "code": "class Solution:\n  def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n    ans = []\n\n    def dfs(s: int, target: int, path: List[int]) -> None:\n      if target < 0:\n        return\n      if target == 0:\n        ans.append(path.copy())\n        return\n\n      for i in range(s, len(candidates)):\n        if i > s and candidates[i] == candidates[i - 1]:\n          continue\n        path.append(candidates[i])\n        dfs(i + 1, target - candidates[i], path)\n        path.pop()\n\n    candidates.sort()\n    dfs(0, target, [])\n    return ans\n"
    }
  ],
  [
    {
      "id": "41. First Missing Positive",
      "code": "class Solution:\n  def firstMissingPositive(self, nums: List[int]) -> int:\n    n = len(nums)\n\n    # Correct slot:\n    # nums[i] = i + 1\n    # nums[i] - 1 = i\n    # nums[nums[i] - 1] = nums[i]\n    for i in range(n):\n      while nums[i] > 0 and nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n        nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n    for i, num in enumerate(nums):\n      if num != i + 1:\n        return i + 1\n\n    return n + 1\n"
    }
  ],
  [
    {
      "id": "42. Trapping Rain Water",
      "code": "class Solution:\n  def trap(self, height: List[int]) -> int:\n    n = len(height)\n    l = [0] * n  # l[i] := max(height[0..i])\n    r = [0] * n  # r[i] := max(height[i..n))\n\n    for i, h in enumerate(height):\n      l[i] = h if i == 0 else max(h, l[i - 1])\n\n    for i, h in reversed(list(enumerate(height))):\n      r[i] = h if i == n - 1 else max(h, r[i + 1])\n\n    return sum(min(l[i], r[i]) - h\n               for i, h in enumerate(height))\n"
    }
  ],
  [
    {
      "id": "43. Multiply Strings",
      "code": "class Solution:\n  def multiply(self, num1: str, num2: str) -> str:\n    s = [0] * (len(num1) + len(num2))\n\n    for i in reversed(range(len(num1))):\n      for j in reversed(range(len(num2))):\n        mult = int(num1[i]) * int(num2[j])\n        summ = mult + s[i + j + 1]\n        s[i + j] += summ // 10\n        s[i + j + 1] = summ % 10\n\n    for i, c in enumerate(s):\n      if c != 0:\n        break\n\n    return ''.join(map(str, s[i:]))\n"
    }
  ],
  [
    {
      "id": "44. Wildcard Matching",
      "code": "class Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    # dp[i][j] := True if s[0..i) matches p[0..j)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return i >= 0 and p[j] == '?' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*':\n        dp[0][j + 1] = dp[0][j]\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          matchEmpty = dp[i + 1][j]\n          matchSome = dp[i][j + 1]\n          dp[i + 1][j + 1] = matchEmpty or matchSome\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]\n"
    }
  ],
  [
    {
      "id": "45. Jump Game II",
      "code": "class Solution:\n  def jump(self, nums: List[int]) -> int:\n    ans = 0\n    end = 0\n    farthest = 0\n\n    # Implicit BFS\n    for i in range(len(nums) - 1):\n      farthest = max(farthest, i + nums[i])\n      if farthest >= len(nums) - 1:\n        ans += 1\n        break\n      if i == end:      # Visited all the items on the current level\n        ans += 1        # Increment the level\n        end = farthest  # Make the queue size for the next level\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "46. Permutations",
      "code": "class Solution:\n  def permute(self, nums: List[int]) -> List[List[int]]:\n    ans = []\n    used = [False] * len(nums)\n\n    def dfs(path: List[int]) -> None:\n      if len(path) == len(nums):\n        ans.append(path.copy())\n        return\n\n      for i, num in enumerate(nums):\n        if used[i]:\n          continue\n        used[i] = True\n        path.append(num)\n        dfs(path)\n        path.pop()\n        used[i] = False\n\n    dfs([])\n    return ans\n"
    }
  ],
  [
    {
      "id": "47. Permutations II",
      "code": "class Solution:\n  def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n    ans = []\n    used = [False] * len(nums)\n\n    def dfs(path: List[int]) -> None:\n      if len(path) == len(nums):\n        ans.append(path.copy())\n        return\n\n      for i, num in enumerate(nums):\n        if used[i]:\n          continue\n        if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n          continue\n        used[i] = True\n        path.append(num)\n        dfs(path)\n        path.pop()\n        used[i] = False\n\n    nums.sort()\n    dfs([])\n    return ans\n"
    }
  ],
  [
    {
      "id": "48. Rotate Image",
      "code": "class Solution:\n  def rotate(self, matrix: List[List[int]]) -> None:\n    matrix.reverse()\n\n    for i in range(len(matrix)):\n      for j in range(i + 1, len(matrix)):\n        matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n"
    }
  ],
  [
    {
      "id": "49. Group Anagrams",
      "code": "class Solution:\n  def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n    dict = collections.defaultdict(list)\n\n    for str in strs:\n      key = ''.join(sorted(str))\n      dict[key].append(str)\n\n    return dict.values()\n"
    }
  ],
  [
    {
      "id": "50. Pow(x, n)",
      "code": "class Solution:\n  def myPow(self, x: float, n: int) -> float:\n    if n == 0:\n      return 1\n    if n < 0:\n      return 1 / self.myPow(x, -n)\n    if n & 1:\n      return x * self.myPow(x, n - 1)\n    return self.myPow(x * x, n // 2)\n"
    }
  ],
  [
    {
      "id": "51. N-Queens",
      "code": "class Solution:\n  def solveNQueens(self, n: int) -> List[List[str]]:\n    ans = []\n    cols = [False] * n\n    diag1 = [False] * (2 * n - 1)\n    diag2 = [False] * (2 * n - 1)\n\n    def dfs(i: int, board: List[int]) -> None:\n      if i == n:\n        ans.append(board)\n        return\n\n      for j in range(n):\n        if cols[j] or diag1[i + j] or diag2[j - i + n - 1]:\n          continue\n        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = True\n        dfs(i + 1, board + ['.' * j + 'Q' + '.' * (n - j - 1)])\n        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = False\n\n    dfs(0, [])\n    return ans\n"
    }
  ],
  [
    {
      "id": "52. N-Queens II",
      "code": "class Solution:\n  def totalNQueens(self, n: int) -> int:\n    ans = 0\n    cols = [False] * n\n    diag1 = [False] * (2 * n - 1)\n    diag2 = [False] * (2 * n - 1)\n\n    def dfs(i: int) -> None:\n      nonlocal ans\n      if i == n:\n        ans += 1\n        return\n\n      for j in range(n):\n        if cols[j] or diag1[i + j] or diag2[j - i + n - 1]:\n          continue\n        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = True\n        dfs(i + 1)\n        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = False\n\n    dfs(0)\n    return ans\n"
    }
  ],
  [
    {
      "id": "53. Maximum Subarray",
      "code": "class Solution:\n  def maxSubArray(self, nums: List[int]) -> int:\n    # dp[i] := max sum subarray ending w// i.\n    dp = [0] * len(nums)\n\n    dp[0] = nums[0]\n    for i in range(1, len(nums)):\n      dp[i] = max(nums[i], dp[i - 1] + nums[i])\n\n    return max(dp)\n"
    }
  ],
  [
    {
      "id": "54. Spiral Matrix",
      "code": "class Solution:\n  def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n    if not matrix:\n      return []\n\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = []\n    r1 = 0\n    c1 = 0\n    r2 = m - 1\n    c2 = n - 1\n\n    # Repeatedly add matrix[r1..r2][c1..c2] to ans\n    while len(ans) < m * n:\n      j = c1\n      while j <= c2 and len(ans) < m * n:\n        ans.append(matrix[r1][j])\n        j += 1\n      i = r1 + 1\n      while i <= r2 - 1 and len(ans) < m * n:\n        ans.append(matrix[i][c2])\n        i += 1\n      j = c2\n      while j >= c1 and len(ans) < m * n:\n        ans.append(matrix[r2][j])\n        j -= 1\n      i = r2 - 1\n      while i >= r1 + 1 and len(ans) < m * n:\n        ans.append(matrix[i][c1])\n        i -= 1\n      r1 += 1\n      c1 += 1\n      r2 -= 1\n      c2 -= 1\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "55. Jump Game",
      "code": "class Solution:\n  def canJump(self, nums: List[int]) -> bool:\n    i = 0\n    reach = 0\n\n    while i < len(nums) and i <= reach:\n      reach = max(reach, i + nums[i])\n      i += 1\n\n    return i == len(nums)\n"
    }
  ],
  [
    {
      "id": "56. Merge Intervals",
      "code": "class Solution:\n  def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n    ans = []\n\n    for interval in sorted(intervals):\n      if not ans or ans[-1][1] < interval[0]:\n        ans.append(interval)\n      else:\n        ans[-1][1] = max(ans[-1][1], interval[1])\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "57. Insert Interval",
      "code": "class Solution:\n  def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n    n = len(intervals)\n    ans = []\n    i = 0\n\n    while i < n and intervals[i][1] < newInterval[0]:\n      ans.append(intervals[i])\n      i += 1\n\n    while i < n and intervals[i][0] <= newInterval[1]:\n      newInterval[0] = min(newInterval[0], intervals[i][0])\n      newInterval[1] = max(newInterval[1], intervals[i][1])\n      i += 1\n\n    ans.append(newInterval)\n\n    while i < n:\n      ans.append(intervals[i])\n      i += 1\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "58. Length of Last Word",
      "code": "class Solution:\n  def lengthOfLastWord(self, s: str) -> int:\n    i = len(s) - 1\n\n    while i >= 0 and s[i] == ' ':\n      i -= 1\n    lastIndex = i\n    while i >= 0 and s[i] != ' ':\n      i -= 1\n\n    return lastIndex - i\n"
    }
  ],
  [
    {
      "id": "59. Spiral Matrix II",
      "code": "class Solution:\n  def generateMatrix(self, n: int) -> List[List[int]]:\n    ans = [[0] * n for _ in range(n)]\n    count = 1\n\n    for min in range(n // 2):\n      max = n - min - 1\n      for i in range(min, max):\n        ans[min][i] = count\n        count += 1\n      for i in range(min, max):\n        ans[i][max] = count\n        count += 1\n      for i in range(max, min, -1):\n        ans[max][i] = count\n        count += 1\n      for i in range(max, min, -1):\n        ans[i][min] = count\n        count += 1\n\n    if n & 1:\n      ans[n // 2][n // 2] = count\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "60. Permutation Sequence",
      "code": "class Solution:\n  def getPermutation(self, n: int, k: int) -> str:\n    ans = ''\n    nums = [i + 1 for i in range(n)]\n    fact = [1] * (n + 1)  # fact[i] := i!\n\n    for i in range(2, n + 1):\n      fact[i] = fact[i - 1] * i\n\n    k -= 1  # 0-indexed\n\n    for i in reversed(range(n)):\n      j = k // fact[i]\n      k %= fact[i]\n      ans += str(nums[j])\n      nums.pop(j)\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "61. Rotate List",
      "code": "class Solution:\n  def rotateRight(self, head: ListNode, k: int) -> ListNode:\n    if not head or not head.next or k == 0:\n      return head\n\n    tail = head\n    length = 1\n    while tail.next:\n      tail = tail.next\n      length += 1\n    tail.next = head  # Circle the list\n\n    t = length - k % length\n    for _ in range(t):\n      tail = tail.next\n    newHead = tail.next\n    tail.next = None\n\n    return newHead\n"
    }
  ],
  [
    {
      "id": "62. Unique Paths",
      "code": "class Solution:\n  def uniquePaths(self, m: int, n: int) -> int:\n    # dp[i][j] := unique paths from (0, 0) to (i, j)\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n      for j in range(1, n):\n        dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n"
    }
  ],
  [
    {
      "id": "63. Unique Paths II",
      "code": "class Solution:\n  def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n    m = len(obstacleGrid)\n    n = len(obstacleGrid[0])\n    # dp[i][j] := unique paths from (0, 0) to (i - 1, j - 1)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    dp[0][1] = 1  # Can also set dp[1][0] = 1\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        if obstacleGrid[i - 1][j - 1] == 0:\n          dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[m][n]\n"
    }
  ],
  [
    {
      "id": "64. Minimum Path Sum",
      "code": "class Solution:\n  def minPathSum(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    for i in range(m):\n      for j in range(n):\n        if i > 0 and j > 0:\n          grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n        elif i > 0:\n          grid[i][0] += grid[i - 1][0]\n        elif j > 0:\n          grid[0][j] += grid[0][j - 1]\n\n    return grid[m - 1][n - 1]\n"
    }
  ],
  [
    {
      "id": "65. Valid Number",
      "code": "class Solution:\n  def isNumber(self, s: str) -> bool:\n    s = s.strip()\n    if not s:\n      return False\n\n    seenNum = False\n    seenDot = False\n    seenE = False\n\n    for i, c in enumerate(s):\n      if c == '.':\n        if seenDot or seenE:\n          return False\n        seenDot = True\n      elif c == 'e' or c == 'E':\n        if seenE or not seenNum:\n          return False\n        seenE = True\n        seenNum = False\n      elif c in '+-':\n        if i > 0 and s[i - 1] != 'e':\n          return False\n        seenNum = False\n      else:\n        if not c.isdigit():\n          return False\n        seenNum = True\n\n    return seenNum\n"
    }
  ],
  [
    {
      "id": "66. Plus One",
      "code": "class Solution:\n  def plusOne(self, digits: List[int]) -> List[int]:\n    for i, d in reversed(list(enumerate(digits))):\n      if d < 9:\n        digits[i] += 1\n        return digits\n      digits[i] = 0\n\n    return [1] + digits\n"
    }
  ],
  [
    {
      "id": "67. Add Binary",
      "code": "class Solution:\n  def addBinary(self, a: str, b: str) -> str:\n    ans = []\n    carry = 0\n    i = len(a) - 1\n    j = len(b) - 1\n\n    while i >= 0 or j >= 0 or carry:\n      if i >= 0:\n        carry += int(a[i])\n        i -= 1\n      if j >= 0:\n        carry += int(b[j])\n        j -= 1\n      ans.append(str(carry % 2))\n      carry //= 2\n\n    return ''.join(ans[::-1])\n"
    }
  ],
  [
    {
      "id": "68. Text Justification",
      "code": "class Solution:\n  def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n    ans = []\n    row = []\n    rowLetters = 0\n\n    for word in words:\n      if rowLetters + len(word) + len(row) > maxWidth:\n        for i in range(maxWidth - rowLetters):\n          row[i % (len(row) - 1 or 1)] += ' '\n        ans.append(''.join(row))\n        row = []\n        rowLetters = 0\n      row.append(word)\n      rowLetters += len(word)\n\n    return ans + [' '.join(row).ljust(maxWidth)]\n"
    }
  ],
  [
    {
      "id": "69. Sqrt(x)",
      "code": "class Solution:\n  def mySqrt(self, x: int) -> int:\n    l = 1\n    r = x + 1\n\n    while l < r:\n      m = (l + r) // 2\n      if m * m > x:\n        r = m\n      else:\n        l = m + 1\n\n    # L: smallest number s.t. l * l > x\n    return l - 1\n"
    }
  ],
  [
    {
      "id": "70. Climbing Stairs",
      "code": "class Solution:\n  def climbStairs(self, n: int) -> int:\n    # dp[i] := # Of distinct ways to climb to i-th stair\n    dp = [1, 1] + [0] * (n - 1)\n\n    for i in range(2, n + 1):\n      dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n"
    }
  ],
  [
    {
      "id": "71. Simplify Path",
      "code": "class Solution:\n  def simplifyPath(self, path: str) -> str:\n    stack = []\n\n    for str in path.split('/'):\n      if str in ('', '.'):\n        continue\n      if str == '..':\n        if stack:\n          stack.pop()\n      else:\n        stack.append(str)\n\n    return '/' + '/'.join(stack)\n"
    }
  ],
  [
    {
      "id": "72. Edit Distance",
      "code": "class Solution:\n  def minDistance(self, word1: str, word2: str) -> int:\n    m = len(word1)\n    n = len(word2)\n    # dp[i][j] := min # Of operations to convert word1[0..i) to word2[0..j)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n      dp[i][0] = i\n\n    for j in range(1, n + 1):\n      dp[0][j] = j\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        if word1[i - 1] == word2[j - 1]:\n          dp[i][j] = dp[i - 1][j - 1]\n        else:\n          dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n\n    return dp[m][n]\n"
    }
  ],
  [
    {
      "id": "73. Set Matrix Zeroes",
      "code": "class Solution:\n  def setZeroes(self, matrix: List[List[int]]) -> None:\n    m = len(matrix)\n    n = len(matrix[0])\n    shouldFillFirstRow = 0 in matrix[0]\n    shouldFillFirstCol = 0 in list(zip(*matrix))[0]\n\n    # Store the information in the 1st row/col\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][j] == 0:\n          matrix[i][0] = 0\n          matrix[0][j] = 0\n\n    # Fill 0s for the matrix except the 1st row/col\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][0] == 0 or matrix[0][j] == 0:\n          matrix[i][j] = 0\n\n    # Fill 0s for the 1st row if needed\n    if shouldFillFirstRow:\n      matrix[0] = [0] * n\n\n    # Fill 0s for the 1st col if needed\n    if shouldFillFirstCol:\n      for row in matrix:\n        row[0] = 0\n"
    }
  ],
  [
    {
      "id": "74. Search a 2D Matrix",
      "code": "class Solution:\n  def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n    if not matrix:\n      return False\n\n    m = len(matrix)\n    n = len(matrix[0])\n    l = 0\n    r = m * n\n\n    while l < r:\n      mid = (l + r) // 2\n      i = mid // n\n      j = mid % n\n      if matrix[i][j] == target:\n        return True\n      if matrix[i][j] < target:\n        l = mid + 1\n      else:\n        r = mid\n\n    return False\n"
    }
  ],
  [
    {
      "id": "75. Sort Colors",
      "code": "class Solution:\n  def sortColors(self, nums: List[int]) -> None:\n    zero = -1\n    one = -1\n    two = -1\n\n    for num in nums:\n      if num == 0:\n        two += 1\n        one += 1\n        zero += 1\n        nums[two] = 2\n        nums[one] = 1\n        nums[zero] = 0\n      elif num == 1:\n        two += 1\n        one += 1\n        nums[two] = 2\n        nums[one] = 1\n      else:\n        two += 1\n        nums[two] = 2\n"
    }
  ],
  [
    {
      "id": "76. Minimum Window Substring",
      "code": "class Solution:\n  def minWindow(self, s: str, t: str) -> str:\n    count = collections.Counter(t)\n    required = len(t)\n    bestLeft = -1\n    minLength = len(s) + 1\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] -= 1\n      if count[c] >= 0:\n        required -= 1\n      while required == 0:\n        if r - l + 1 < minLength:\n          bestLeft = l\n          minLength = r - l + 1\n        count[s[l]] += 1\n        if count[s[l]] > 0:\n          required += 1\n        l += 1\n\n    return '' if bestLeft == -1 else s[bestLeft: bestLeft + minLength]\n"
    }
  ],
  [
    {
      "id": "77. Combinations",
      "code": "class Solution:\n  def combine(self, n: int, k: int) -> List[List[int]]:\n    ans = []\n\n    def dfs(s: int, path: List[int]) -> None:\n      if len(path) == k:\n        ans.append(path.copy())\n        return\n\n      for i in range(s, n + 1):\n        path.append(i)\n        dfs(i + 1, path)\n        path.pop()\n\n    dfs(1, [])\n    return ans\n"
    }
  ],
  [
    {
      "id": "78. Subsets",
      "code": "class Solution:\n  def subsets(self, nums: List[int]) -> List[List[int]]:\n    ans = []\n\n    def dfs(s: int, path: List[int]) -> None:\n      ans.append(path)\n\n      for i in range(s, len(nums)):\n        dfs(i + 1, path + [nums[i]])\n\n    dfs(0, [])\n    return ans\n"
    }
  ],
  [
    {
      "id": "79. Word Search",
      "code": "class Solution:\n  def exist(self, board: List[List[str]], word: str) -> bool:\n    m = len(board)\n    n = len(board[0])\n\n    def dfs(i: int, j: int, s: int) -> bool:\n      if i < 0 or i == m or j < 0 or j == n:\n        return False\n      if board[i][j] != word[s] or board[i][j] == '*':\n        return False\n      if s == len(word) - 1:\n        return True\n\n      cache = board[i][j]\n      board[i][j] = '*'\n      isExist = \\\n          dfs(i + 1, j, s + 1) or \\\n          dfs(i - 1, j, s + 1) or \\\n          dfs(i, j + 1, s + 1) or \\\n          dfs(i, j - 1, s + 1)\n      board[i][j] = cache\n\n      return isExist\n\n    return any(dfs(i, j, 0) for i in range(m) for j in range(n))\n"
    }
  ],
  [
    {
      "id": "80. Remove Duplicates from Sorted Array II",
      "code": "class Solution:\n  def removeDuplicates(self, nums: List[int]) -> int:\n    i = 0\n\n    for num in nums:\n      if i < 2 or num != nums[i - 2]:\n        nums[i] = num\n        i += 1\n\n    return i\n"
    }
  ],
  [
    {
      "id": "81. Search in Rotated Sorted Array II",
      "code": "class Solution:\n  def search(self, nums: List[int], target: int) -> bool:\n    l = 0\n    r = len(nums) - 1\n\n    while l <= r:\n      m = (l + r) // 2\n      if nums[m] == target:\n        return True\n      if nums[l] == nums[m] == nums[r]:\n        l += 1\n        r -= 1\n      elif nums[l] <= nums[m]:  # nums[l..m] are sorted\n        if nums[l] <= target < nums[m]:\n          r = m - 1\n        else:\n          l = m + 1\n      else:  # nums[m..n - 1] are sorted\n        if nums[m] < target <= nums[r]:\n          l = m + 1\n        else:\n          r = m - 1\n\n    return False\n"
    }
  ],
  [
    {
      "id": "82. Remove Duplicates from Sorted List II",
      "code": "class Solution:\n  def deleteDuplicates(self, head: ListNode) -> ListNode:\n    dummy = ListNode(0, head)\n    prev = dummy\n\n    while head:\n      while head.next and head.val == head.next.val:\n        head = head.next\n      if prev.next == head:\n        prev = prev.next\n      else:\n        prev.next = head.next\n      head = head.next\n\n    return dummy.next\n"
    }
  ],
  [
    {
      "id": "83. Remove Duplicates from Sorted List",
      "code": "class Solution:\n  def deleteDuplicates(self, head: ListNode) -> ListNode:\n    curr = head\n\n    while curr:\n      while curr.next and curr.val == curr.next.val:\n        curr.next = curr.next.next\n      curr = curr.next\n\n    return head\n"
    }
  ],
  [
    {
      "id": "84. Largest Rectangle in Histogram",
      "code": "class Solution:\n  def largestRectangleArea(self, heights: List[int]) -> int:\n    ans = 0\n    stack = []\n\n    for i in range(len(heights) + 1):\n      while stack and (i == len(heights) or heights[stack[-1]] > heights[i]):\n        h = heights[stack.pop()]\n        w = i - stack[-1] - 1 if stack else i\n        ans = max(ans, h * w)\n      stack.append(i)\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "85. Maximal Rectangle",
      "code": "class Solution:\n  def maximalRectangle(self, matrix: List[List[str]]) -> int:\n    if not matrix:\n      return 0\n\n    ans = 0\n    hist = [0] * len(matrix[0])\n\n    def largestRectangleArea(heights: List[int]) -> int:\n      ans = 0\n      stack = []\n\n      for i in range(len(heights) + 1):\n        while stack and (i == len(heights) or heights[stack[-1]] > heights[i]):\n          h = heights[stack.pop()]\n          w = i - stack[-1] - 1 if stack else i\n          ans = max(ans, h * w)\n        stack.append(i)\n\n      return ans\n\n    for row in matrix:\n      for i, num in enumerate(row):\n        hist[i] = 0 if num == '0' else hist[i] + 1\n      ans = max(ans, largestRectangleArea(hist))\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "86. Partition List",
      "code": "class Solution:\n  def partition(self, head: ListNode, x: int) -> ListNode:\n    beforeHead = ListNode(0)\n    afterHead = ListNode(0)\n    before = beforeHead\n    after = afterHead\n\n    while head:\n      if head.val < x:\n        before.next = head\n        before = head\n      else:\n        after.next = head\n        after = head\n      head = head.next\n\n    after.next = None\n    before.next = afterHead.next\n\n    return beforeHead.next\n"
    }
  ],
  [
    {
      "id": "87. Scramble String",
      "code": "class Solution:\n  def isScramble(self, s1: str, s2: str) -> bool:\n    if s1 == s2:\n      return True\n    if len(s1) != len(s2):\n      return False\n    if collections.Counter(s1) != collections.Counter(s2):\n      return False\n\n    for i in range(1, len(s1)):\n      if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n        return True\n      if self.isScramble(s1[:i], s2[len(s2) - i:]) and self.isScramble(s1[i:], s2[:len(s2) - i]):\n        return True\n\n    return False\n"
    }
  ],
  [
    {
      "id": "88. Merge Sorted Array",
      "code": "class Solution:\n  def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n    i = m - 1      # nums1's index (actual nums)\n    j = n - 1      # nums2's index\n    k = m + n - 1  # nums1's index (next filled position)\n\n    while j >= 0:\n      if i >= 0 and nums1[i] > nums2[j]:\n        nums1[k] = nums1[i]\n        k -= 1\n        i -= 1\n      else:\n        nums1[k] = nums2[j]\n        k -= 1\n        j -= 1\n"
    }
  ],
  [
    {
      "id": "89. Gray Code",
      "code": "class Solution:\n  def grayCode(self, n: int) -> List[int]:\n    ans = [0]\n\n    for i in range(n):\n      for j in reversed(range(len(ans))):\n        ans.append(ans[j] | 1 << i)\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "90. Subsets II",
      "code": "class Solution:\n  def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n    ans = []\n\n    def dfs(s: int, path: List[int]) -> None:\n      ans.append(path)\n      if s == len(nums):\n        return\n\n      for i in range(s, len(nums)):\n        if i > s and nums[i] == nums[i - 1]:\n          continue\n        dfs(i + 1, path + [nums[i]])\n\n    nums.sort()\n    dfs(0, [])\n    return ans\n"
    }
  ],
  [
    {
      "id": "91. Decode Ways",
      "code": "class Solution:\n  def numDecodings(self, s: str) -> int:\n    n = len(s)\n    # dp[i] := # Of ways to decode s[i..n)\n    dp = [0] * n + [1]\n\n    def isValid(a: chr, b=None) -> bool:\n      if b:\n        return a == '1' or a == '2' and b < '7'\n      return a != '0'\n\n    if isValid(s[-1]):\n      dp[n - 1] = 1\n\n    for i in reversed(range(n - 1)):\n      if isValid(s[i]):\n        dp[i] += dp[i + 1]\n      if isValid(s[i], s[i + 1]):\n        dp[i] += dp[i + 2]\n\n    return dp[0]\n"
    }
  ],
  [
    {
      "id": "92. Reverse Linked List II",
      "code": "class Solution:\n  def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\n    if left == 1:\n      return self.reverseN(head, right)\n\n    head.next = self.reverseBetween(head.next, left - 1, right - 1)\n    return head\n\n  def reverseN(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n    if n == 1:\n      return head\n\n    newHead = self.reverseN(head.next, n - 1)\n    headNext = head.next\n    head.next = headNext.next\n    headNext.next = head\n    return newHead\n"
    }
  ],
  [
    {
      "id": "93. Restore IP Addresses",
      "code": "class Solution:\n  def restoreIpAddresses(self, s: str) -> List[str]:\n    ans = []\n\n    def dfs(start: int, path: List[int]) -> None:\n      if len(path) == 4 and start == len(s):\n        ans.append(path[0] + '.' + path[1] + '.' + path[2] + '.' + path[3])\n        return\n      if len(path) == 4 or start == len(s):\n        return\n\n      for length in range(1, 4):\n        if start + length > len(s):\n          return  # Out of bound\n        if length > 1 and s[start] == '0':\n          return  # Leading '0'\n        num = s[start: start + length]\n        if int(num) > 255:\n          return\n        dfs(start + length, path + [num])\n\n    dfs(0, [])\n    return ans\n"
    }
  ],
  [
    {
      "id": "94. Binary Tree Inorder Traversal",
      "code": "class Solution:\n  def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n    ans = []\n    stack = []\n\n    while root or stack:\n      while root:\n        stack.append(root)\n        root = root.left\n      root = stack.pop()\n      ans.append(root.val)\n      root = root.right\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "95. Unique Binary Search Trees II",
      "code": "class Solution:\n  def generateTrees(self, n: int) -> List[TreeNode]:\n    if n == 0:\n      return []\n\n    def generateTrees(mini: int, maxi: int) -> List[Optional[int]]:\n      if mini > maxi:\n        return [None]\n\n      ans = []\n\n      for i in range(mini, maxi + 1):\n        for left in generateTrees(mini, i - 1):\n          for right in generateTrees(i + 1, maxi):\n            ans.append(TreeNode(i))\n            ans[-1].left = left\n            ans[-1].right = right\n\n      return ans\n\n    return generateTrees(1, n)\n"
    }
  ],
  [
    {
      "id": "96. Unique Binary Search Trees",
      "code": "class Solution:\n  def numTrees(self, n: int) -> int:\n    # G[i] := # Of unique BST's that store values 1..i\n    G = [1, 1] + [0] * (n - 1)\n\n    for i in range(2, n + 1):\n      for j in range(i):\n        G[i] += G[j] * G[i - j - 1]\n\n    return G[n]\n"
    }
  ],
  [
    {
      "id": "97. Interleaving String",
      "code": "class Solution:\n  def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n    m = len(s1)\n    n = len(s2)\n    if m + n != len(s3):\n      return False\n\n    # dp[i][j] := true if s3[0..i + j) is formed by the interleaving of\n    #             s1[0..i) and s2[0..j)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for i in range(1, m + 1):\n      dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n    for j in range(1, n + 1):\n      dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or \\\n            (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n\n    return dp[m][n]\n"
    }
  ],
  [
    {
      "id": "98. Validate Binary Search Tree",
      "code": "class Solution:\n  def isValidBST(self, root: Optional[TreeNode]) -> bool:\n    def isValidBST(root: Optional[TreeNode],\n                   minNode: Optional[TreeNode], maxNode: Optional[TreeNode]) -> bool:\n      if not root:\n        return True\n      if minNode and root.val <= minNode.val:\n        return False\n      if maxNode and root.val >= maxNode.val:\n        return False\n\n      return isValidBST(root.left, minNode, root) and \\\n          isValidBST(root.right, root, maxNode)\n\n    return isValidBST(root, None, None)\n"
    }
  ],
  [
    {
      "id": "99. Recover Binary Search Tree",
      "code": "class Solution:\n  def recoverTree(self, root: Optional[TreeNode]) -> None:\n    def swap(x: Optional[TreeNode], y: Optional[TreeNode]) -> None:\n      temp = x.val\n      x.val = y.val\n      y.val = temp\n\n    def inorder(root: Optional[TreeNode]) -> None:\n      if not root:\n        return\n\n      inorder(root.left)\n\n      if self.pred and root.val < self.pred.val:\n        self.y = root\n        if not self.x:\n          self.x = self.pred\n        else:\n          return\n      self.pred = root\n\n      inorder(root.right)\n\n    inorder(root)\n    swap(self.x, self.y)\n\n  pred = None\n  x = None  # 1st wrong node\n  y = None  # 2nd wrong node\n"
    }
  ],
  [
    {
      "id": "100. Same Tree",
      "code": "class Solution:\n  def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n    if not p or not q:\n      return p == q\n    return p.val == q.val and \\\n        self.isSameTree(p.left, q.left) and \\\n        self.isSameTree(p.right, q.right)\n"
    }
  ],
  [
    {
      "id": "101. Symmetric Tree",
      "code": "class Solution:\n  def isSymmetric(self, root: Optional[TreeNode]) -> bool:\n    def isSymmetric(p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n      if not p or not q:\n        return p == q\n\n      return p.val == q.val and \\\n          isSymmetric(p.left, q.right) and \\\n          isSymmetric(p.right, q.left)\n\n    return isSymmetric(root, root)\n"
    }
  ],
  [
    {
      "id": "102. Binary Tree Level Order Traversal",
      "code": "class Solution:\n  def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n    if not root:\n      return []\n\n    ans = []\n    q = collections.deque([root])\n\n    while q:\n      currLevel = []\n      for _ in range(len(q)):\n        node = q.popleft()\n        currLevel.append(node.val)\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      ans.append(currLevel)\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "103. Binary Tree Zigzag Level Order Traversal",
      "code": "class Solution:\n  def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n    if not root:\n      return []\n\n    ans = []\n    q = collections.deque([root])\n    isLeftToRight = True\n\n    while q:\n      currLevel = []\n      for _ in range(len(q)):\n        if isLeftToRight:\n          node = q.popleft()\n          currLevel.append(node.val)\n          if node.left:\n            q.append(node.left)\n          if node.right:\n            q.append(node.right)\n        else:\n          node = q.pop()\n          currLevel.append(node.val)\n          if node.right:\n            q.appendleft(node.right)\n          if node.left:\n            q.appendleft(node.left)\n      ans.append(currLevel)\n      isLeftToRight = not isLeftToRight\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "104. Maximum Depth of Binary Tree",
      "code": "class Solution:\n  def maxDepth(self, root: Optional[TreeNode]) -> int:\n    if not root:\n      return 0\n    return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n"
    }
  ],
  [
    {
      "id": "105. Construct Binary Tree from Preorder and Inorder Traversal",
      "code": "class Solution:\n  def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n    inToIndex = {num: i for i, num in enumerate(inorder)}\n\n    def build(preStart: int, preEnd: int, inStart: int, inEnd: int) -> Optional[TreeNode]:\n      if preStart > preEnd:\n        return None\n\n      rootVal = preorder[preStart]\n      rootInIndex = inToIndex[rootVal]\n      leftSize = rootInIndex - inStart\n\n      root = TreeNode(rootVal)\n      root.left = build(preStart + 1, preStart + leftSize,\n                        inStart, rootInIndex - 1)\n      root.right = build(preStart + leftSize + 1,\n                         preEnd, rootInIndex + 1, inEnd)\n      return root\n\n    return build(0, len(preorder) - 1, 0, len(inorder) - 1)\n"
    }
  ],
  [
    {
      "id": "106. Construct Binary Tree from Inorder and Postorder Traversal",
      "code": "class Solution:\n  def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n    inToIndex = {num: i for i, num in enumerate(inorder)}\n\n    def build(inStart: int, inEnd: int, postStart: int, postEnd: int) -> Optional[TreeNode]:\n      if inStart > inEnd:\n        return None\n\n      rootVal = postorder[postEnd]\n      rootInIndex = inToIndex[rootVal]\n      leftSize = rootInIndex - inStart\n\n      root = TreeNode(rootVal)\n      root.left = build(inStart, rootInIndex - 1,  postStart,\n                        postStart + leftSize - 1)\n      root.right = build(rootInIndex + 1, inEnd,  postStart + leftSize,\n                         postEnd - 1)\n      return root\n\n    return build(0, len(inorder) - 1, 0, len(postorder) - 1)\n"
    }
  ],
  [
    {
      "id": "107. Binary Tree Level Order Traversal II",
      "code": "class Solution:\n  def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n    if not root:\n      return []\n\n    ans = []\n    q = collections.deque([root])\n\n    while q:\n      currLevel = []\n      for _ in range(len(q)):\n        node = q.popleft()\n        currLevel.append(node.val)\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      ans.append(currLevel)\n\n    return ans[::-1]\n"
    }
  ],
  [
    {
      "id": "108. Convert Sorted Array to Binary Search Tree",
      "code": "class Solution:\n  def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:\n    def build(l: int, r: int) -> Optional[TreeNode]:\n      if l > r:\n        return None\n\n      m = (l + r) // 2\n      return TreeNode(nums[m],\n                      build(l, m - 1),\n                      build(m + 1, r))\n\n    return build(0, len(nums) - 1)\n"
    }
  ],
  [
    {
      "id": "109. Convert Sorted List to Binary Search Tree",
      "code": "class Solution:\n  def sortedListToBST(self, head: ListNode) -> TreeNode:\n    def findMid(head: ListNode) -> ListNode:\n      prev = None\n      slow = head\n      fast = head\n\n      while fast and fast.next:\n        prev = slow\n        slow = slow.next\n        fast = fast.next.next\n      prev.next = None\n\n      return slow\n\n    if not head:\n      return None\n    if not head.next:\n      return TreeNode(head.val)\n\n    mid = findMid(head)\n    root = TreeNode(mid.val)\n    root.left = self.sortedListToBST(head)\n    root.right = self.sortedListToBST(mid.next)\n\n    return root\n"
    }
  ],
  [
    {
      "id": "110. Balanced Binary Tree",
      "code": "class Solution:\n  def isBalanced(self, root: Optional[TreeNode]) -> bool:\n    if not root:\n      return True\n\n    def maxDepth(root: Optional[TreeNode]) -> int:\n      if not root:\n        return 0\n      return 1 + max(maxDepth(root.left), maxDepth(root.right))\n\n    return abs(maxDepth(root.left) - maxDepth(root.right)) <= 1 and \\\n        self.isBalanced(root.left) and self.isBalanced(root.right)\n"
    }
  ],
  [
    {
      "id": "111. Minimum Depth of Binary Tree",
      "code": "class Solution:\n  def minDepth(self, root: Optional[TreeNode]) -> int:\n    if not root:\n      return 0\n    if not root.left:\n      return self.minDepth(root.right) + 1\n    if not root.right:\n      return self.minDepth(root.left) + 1\n    return min(self.minDepth(root.left), self.minDepth(root.right)) + 1\n"
    }
  ],
  [
    {
      "id": "112. Path Sum",
      "code": "class Solution:\n  def hasPathSum(self, root: TreeNode, summ: int) -> bool:\n    if not root:\n      return False\n    if root.val == summ and not root.left and not root.right:\n      return True\n    return self.hasPathSum(root.left, summ - root.val) or \\\n        self.hasPathSum(root.right, summ - root.val)\n"
    }
  ],
  [
    {
      "id": "113. Path Sum II",
      "code": "class Solution:\n  def pathSum(self, root: TreeNode, summ: int) -> List[List[int]]:\n    ans = []\n\n    def dfs(root: TreeNode, summ: int, path: List[int]) -> None:\n      if not root:\n        return\n      if root.val == summ and not root.left and not root.right:\n        ans.append(path + [root.val])\n        return\n\n      dfs(root.left, summ - root.val, path + [root.val])\n      dfs(root.right, summ - root.val, path + [root.val])\n\n    dfs(root, summ, [])\n    return ans\n"
    }
  ],
  [
    {
      "id": "114. Flatten Binary Tree to Linked List",
      "code": "class Solution:\n  def flatten(self, root: Optional[TreeNode]) -> None:\n    if not root:\n      return\n\n    self.flatten(root.left)\n    self.flatten(root.right)\n\n    left = root.left  # Flattened left\n    right = root.right  # Flattened right\n\n    root.left = None\n    root.right = left\n\n    # Connect the original right subtree\n    # To the end of new right subtree\n    rightmost = root\n    while rightmost.right:\n      rightmost = rightmost.right\n    rightmost.right = right\n"
    }
  ],
  [
    {
      "id": "115. Distinct Subsequences",
      "code": "class Solution:\n  def numDistinct(self, s: str, t: str) -> int:\n    m = len(s)\n    n = len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n      dp[i][0] = 1\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        if s[i - 1] == t[j - 1]:\n          dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n        else:\n          dp[i][j] = dp[i - 1][j]\n\n    return dp[m][n]\n"
    }
  ],
  [
    {
      "id": "116. Populating Next Right Pointers in Each Node",
      "code": "class Solution:\n  def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':\n    if not root:\n      return None\n\n    def connectTwoNodes(p, q) -> None:\n      if not p:\n        return\n      p.next = q\n      connectTwoNodes(p.left, p.right)\n      connectTwoNodes(q.left, q.right)\n      connectTwoNodes(p.right, q.left)\n\n    connectTwoNodes(root.left, root.right)\n    return root\n"
    }
  ],
  [
    {
      "id": "117. Populating Next Right Pointers in Each Node II",
      "code": "class Solution:\n  def connect(self, root: 'Node') -> 'Node':\n    node = root  # The node just above current needling\n\n    while node:\n      dummy = Node(0)  # Dummy node before needling\n      # Needle children of node\n      needle = dummy\n      while node:\n        if node.left:  # Needle left child\n          needle.next = node.left\n          needle = needle.next\n        if node.right:  # Needle right child\n          needle.next = node.right\n          needle = needle.next\n        node = node.next\n      node = dummy.next  # Move node to the next level\n\n    return root\n"
    }
  ],
  [
    {
      "id": "118. Pascal's Triangle",
      "code": "class Solution:\n  def generate(self, numRows: int) -> List[List[int]]:\n    ans = []\n\n    for i in range(numRows):\n      ans.append([1] * (i + 1))\n\n    for i in range(2, numRows):\n      for j in range(1, len(ans[i]) - 1):\n        ans[i][j] = ans[i - 1][j - 1] + ans[i - 1][j]\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "119. Pascal's Triangle II",
      "code": "class Solution:\n  def getRow(self, rowIndex: int) -> List[int]:\n    ans = [1] * (rowIndex + 1)\n\n    for i in range(2, rowIndex + 1):\n      for j in range(1, i):\n        ans[i - j] += ans[i - j - 1]\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "120. Triangle",
      "code": "class Solution:\n  def minimumTotal(self, triangle: List[List[int]]) -> int:\n    for i in reversed(range(len(triangle) - 1)):\n      for j in range(i + 1):\n        triangle[i][j] += min(triangle[i + 1][j],\n                              triangle[i + 1][j + 1])\n\n    return triangle[0][0]\n"
    }
  ],
  [
    {
      "id": "121. Best Time to Buy and Sell Stock",
      "code": "class Solution:\n  def maxProfit(self, prices: List[int]) -> int:\n    sellOne = 0\n    holdOne = -math.inf\n\n    for price in prices:\n      sellOne = max(sellOne, holdOne + price)\n      holdOne = max(holdOne, -price)\n\n    return sellOne\n"
    }
  ],
  [
    {
      "id": "122. Best Time to Buy and Sell Stock II",
      "code": "class Solution:\n  def maxProfit(self, prices: List[int]) -> int:\n    sell = 0\n    hold = -math.inf\n\n    for price in prices:\n      sell = max(sell, hold + price)\n      hold = max(hold, sell - price)\n\n    return sell\n"
    }
  ],
  [
    {
      "id": "123. Best Time to Buy and Sell Stock III",
      "code": "class Solution:\n  def maxProfit(self, prices: List[int]) -> int:\n    sellTwo = 0\n    holdTwo = -math.inf\n    sellOne = 0\n    holdOne = -math.inf\n\n    for price in prices:\n      sellTwo = max(sellTwo, holdTwo + price)\n      holdTwo = max(holdTwo, sellOne - price)\n      sellOne = max(sellOne, holdOne + price)\n      holdOne = max(holdOne, -price)\n\n    return sellTwo\n"
    }
  ],
  [
    {
      "id": "124. Binary Tree Maximum Path Sum",
      "code": "class Solution:\n  def maxPathSum(self, root: Optional[TreeNode]) -> int:\n    ans = -math.inf\n\n    def maxPathSumDownFrom(root: Optional[TreeNode]) -> int:\n      nonlocal ans\n      if not root:\n        return 0\n\n      l = max(0, maxPathSumDownFrom(root.left))\n      r = max(0, maxPathSumDownFrom(root.right))\n      ans = max(ans, root.val + l + r)\n      return root.val + max(l, r)\n\n    maxPathSumDownFrom(root)\n    return ans\n"
    }
  ],
  [
    {
      "id": "125. Valid Palindrome",
      "code": "class Solution:\n  def isPalindrome(self, s: str) -> bool:\n    l = 0\n    r = len(s) - 1\n\n    while l < r:\n      while l < r and not s[l].isalnum():\n        l += 1\n      while l < r and not s[r].isalnum():\n        r -= 1\n      if s[l].lower() != s[r].lower():\n        return False\n      l += 1\n      r -= 1\n\n    return True\n"
    }
  ],
  [
    {
      "id": "126. Word Ladder II",
      "code": "class Solution:\n  def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n    wordSet = set(wordList)\n    if endWord not in wordList:\n      return []\n\n    # {\"hit\": [\"hot\"], \"hot\": [\"dot\", \"lot\"], ...}\n    graph: Dict[str, List[str]] = collections.defaultdict(list)\n\n    # Build graph from beginWord -> endWord\n    if not self._bfs(beginWord, endWord, wordSet, graph):\n      return []\n\n    ans = []\n\n    self._dfs(graph, beginWord, endWord, [beginWord], ans)\n    return ans\n\n  def _bfs(self, beginWord: str, endWord: str, wordSet: Set[str], graph: Dict[str, List[str]]) -> bool:\n    currentLevelWords = {beginWord}\n\n    while currentLevelWords:\n      for word in currentLevelWords:\n        wordSet.discard(word)\n      nextLevelWords = set()\n      reachEndWord = False\n      for parent in currentLevelWords:\n        for child in self._getChildren(parent, wordSet):\n          if child in wordSet:\n            nextLevelWords.add(child)\n            graph[parent].append(child)\n          if child == endWord:\n            reachEndWord = True\n      if reachEndWord:\n        return True\n      currentLevelWords = nextLevelWords\n\n    return False\n\n  def _getChildren(self, parent: str, wordSet: Set[str]) -> List[str]:\n    children = []\n    s = list(parent)\n\n    for i, cache in enumerate(s):\n      for c in string.ascii_lowercase:\n        if c == cache:\n          continue\n        s[i] = c\n        child = ''.join(s)\n        if child in wordSet:\n          children.append(child)\n      s[i] = cache\n\n    return children\n\n  def _dfs(self, graph: Dict[str, List[str]], word: str, endWord: str, path: List[str], ans: List[List[str]]) -> None:\n    if word == endWord:\n      ans.append(path.copy())\n      return\n\n    for child in graph.get(word, []):\n      path.append(child)\n      self._dfs(graph, child, endWord, path, ans)\n      path.pop()\n"
    }
  ],
  [
    {
      "id": "127. Word Ladder",
      "code": "class Solution:\n  def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n    wordSet = set(wordList)\n    if endWord not in wordSet:\n      return 0\n\n    ans = 0\n    q = collections.deque([beginWord])\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        wordList = list(q.popleft())\n        for i, cache in enumerate(wordList):\n          for c in string.ascii_lowercase:\n            wordList[i] = c\n            word = ''.join(wordList)\n            if word == endWord:\n              return ans + 1\n            if word in wordSet:\n              q.append(word)\n              wordSet.remove(word)\n          wordList[i] = cache\n\n    return 0\n"
    }
  ],
  [
    {
      "id": "128. Longest Consecutive Sequence",
      "code": "class Solution:\n  def longestConsecutive(self, nums: List[int]) -> int:\n    ans = 0\n    seen = set(nums)\n\n    for num in nums:\n      if num - 1 in seen:\n        continue\n      length = 0\n      while num in seen:\n        num += 1\n        length += 1\n      ans = max(ans, length)\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "129. Sum Root to Leaf Numbers",
      "code": "class Solution:\n  def sumNumbers(self, root: Optional[TreeNode]) -> int:\n    ans = 0\n\n    def dfs(root: Optional[TreeNode], path: int) -> None:\n      nonlocal ans\n      if not root:\n        return\n      if not root.left and not root.right:\n        ans += path * 10 + root.val\n        return\n\n      dfs(root.left, path * 10 + root.val)\n      dfs(root.right, path * 10 + root.val)\n\n    dfs(root, 0)\n    return ans\n"
    }
  ],
  [
    {
      "id": "130. Surrounded Regions",
      "code": "class Solution:\n  def solve(self, board: List[List[str]]) -> None:\n    if not board:\n      return\n\n    m = len(board)\n    n = len(board[0])\n    dirs = [0, 1, 0, -1, 0]\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if board[i][j] == 'O':\n            q.append((i, j))\n            board[i][j] = '*'\n\n    # Mark grids that stretch from four sides with '*'\n    while q:\n      i, j = q.popleft()\n      for k in range(4):\n        x = i + dirs[k]\n        y = j + dirs[k + 1]\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if board[x][y] != 'O':\n          continue\n        q.append((x, y))\n        board[x][y] = '*'\n\n    for row in board:\n      for i, c in enumerate(row):\n        row[i] = 'O' if c == '*' else 'X'\n"
    }
  ],
  [
    {
      "id": "131. Palindrome Partitioning",
      "code": "class Solution:\n  def partition(self, s: str) -> List[List[str]]:\n    ans = []\n\n    def isPalindrome(s: str) -> bool:\n      return s == s[::-1]\n\n    def dfs(s: str, j: int, path: List[str], ans: List[List[str]]) -> None:\n      if j == len(s):\n        ans.append(path)\n        return\n\n      for i in range(j, len(s)):\n        if isPalindrome(s[j: i + 1]):\n          dfs(s, i + 1, path + [s[j: i + 1]], ans)\n\n    dfs(s, 0, [], ans)\n    return ans\n"
    }
  ],
  [
    {
      "id": "132. Palindrome Partitioning II",
      "code": "class Solution:\n  def minCut(self, s: str) -> int:\n    n = len(s)\n    cut = [0] * n\n    dp = [[False] * n for _ in range(n)]\n\n    for i in range(n):\n      mini = i\n      for j in range(i + 1):\n        if s[j] == s[i] and (j + 1 > i - 1 or dp[j + 1][i - 1]):\n          dp[j][i] = True\n          mini = 0 if j == 0 else min(mini, cut[j - 1] + 1)\n      cut[i] = mini\n\n    return cut[n - 1]\n"
    }
  ],
  [
    {
      "id": "133. Clone Graph",
      "code": "class Solution:\n  def cloneGraph(self, node: 'Node') -> 'Node':\n    if not node:\n      return None\n\n    q = collections.deque([node])\n    map = {node: Node(node.val)}\n\n    while q:\n      u = q.popleft()\n      for v in u.neighbors:\n        if v not in map:\n          map[v] = Node(v.val)\n          q.append(v)\n        map[u].neighbors.append(map[v])\n\n    return map[node]\n"
    }
  ],
  [
    {
      "id": "134. Gas Station",
      "code": "class Solution:\n  def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n    ans = 0\n    net = 0\n    summ = 0\n\n    for i in range(len(gas)):\n      net += gas[i] - cost[i]\n      summ += gas[i] - cost[i]\n      if summ < 0:\n        summ = 0\n        ans = i + 1\n\n    return -1 if net < 0 else ans\n"
    }
  ],
  [
    {
      "id": "135. Candy",
      "code": "class Solution:\n  def candy(self, ratings: List[int]) -> int:\n    n = len(ratings)\n\n    ans = 0\n    l = [1] * n\n    r = [1] * n\n\n    for i in range(1, n):\n      if ratings[i] > ratings[i - 1]:\n        l[i] = l[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n      if ratings[i] > ratings[i + 1]:\n        r[i] = r[i + 1] + 1\n\n    for a, b in zip(l, r):\n      ans += max(a, b)\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "136. Single Number",
      "code": "class Solution:\n  def singleNumber(self, nums: List[int]) -> int:\n    return functools.reduce(lambda x, y: x ^ y, nums, 0)\n"
    }
  ],
  [
    {
      "id": "137. Single Number II",
      "code": "class Solution:\n  def singleNumber(self, nums: List[int]) -> int:\n    ones = 0\n    twos = 0\n\n    for num in nums:\n      ones ^= num & ~twos\n      twos ^= num & ~ones\n\n    return ones\n"
    }
  ],
  [
    {
      "id": "138. Copy List with Random Pointer",
      "code": "class Solution:\n  def copyRandomList(self, head: 'Node') -> 'Node':\n    if not head:\n      return None\n    if head in self.map:\n      return self.map[head]\n\n    newNode = Node(head.val)\n    self.map[head] = newNode\n    newNode.next = self.copyRandomList(head.next)\n    newNode.random = self.copyRandomList(head.random)\n    return newNode\n\n  map = {}\n"
    }
  ],
  [
    {
      "id": "139. Word Break",
      "code": "class Solution:\n  def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n    wordSet = set(wordDict)\n\n    @functools.lru_cache(None)\n    def wordBreak(s: str) -> bool:\n      if s in wordSet:\n        return True\n      return any(s[:i] in wordSet and wordBreak(s[i:]) for i in range(len(s)))\n\n    return wordBreak(s)\n"
    }
  ],
  [
    {
      "id": "140. Word Break II",
      "code": "class Solution:\n  def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n    wordSet = set(wordDict)\n\n    @functools.lru_cache(None)\n    def wordBreak(s: str) -> List[str]:\n      ans = []\n\n      # 1 <= len(prefix) < len(s)\n      for i in range(1, len(s)):\n        prefix = s[0:i]\n        suffix = s[i:]\n        if prefix in wordSet:\n          for word in wordBreak(suffix):\n            ans.append(prefix + ' ' + word)\n\n      # Contains whole string, so don't add any space\n      if s in wordSet:\n        ans.append(s)\n\n      return ans\n\n    return wordBreak(s)\n"
    }
  ],
  [
    {
      "id": "141. Linked List Cycle",
      "code": "class Solution:\n  def hasCycle(self, head: ListNode) -> bool:\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n      slow = slow.next\n      fast = fast.next.next\n      if slow == fast:\n        return True\n\n    return False\n"
    }
  ],
  [
    {
      "id": "142. Linked List Cycle II",
      "code": "class Solution:\n  def detectCycle(self, head: ListNode) -> ListNode:\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n      slow = slow.next\n      fast = fast.next.next\n      if slow == fast:\n        slow = head\n        while slow != fast:\n          slow = slow.next\n          fast = fast.next\n        return slow\n\n    return None\n"
    }
  ],
  [
    {
      "id": "143. Reorder List",
      "code": "class Solution:\n  def reorderList(self, head: ListNode) -> None:\n    def findMid(head: ListNode):\n      prev = None\n      slow = head\n      fast = head\n\n      while fast and fast.next:\n        prev = slow\n        slow = slow.next\n        fast = fast.next.next\n      prev.next = None\n\n      return slow\n\n    def reverse(head: ListNode) -> ListNode:\n      prev = None\n      curr = head\n\n      while curr:\n        next = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next\n\n      return prev\n\n    def merge(l1: ListNode, l2: ListNode) -> None:\n      while l2:\n        next = l1.next\n        l1.next = l2\n        l1 = l2\n        l2 = next\n\n    if not head or not head.next:\n      return\n\n    mid = findMid(head)\n    reversed = reverse(mid)\n    merge(head, reversed)\n"
    }
  ],
  [
    {
      "id": "144. Binary Tree Preorder Traversal",
      "code": "class Solution:\n  def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n    ans = []\n\n    def preorder(root: Optional[TreeNode]) -> None:\n      if not root:\n        return\n\n      ans.append(root.val)\n      preorder(root.left)\n      preorder(root.right)\n\n    preorder(root)\n    return ans\n"
    }
  ],
  [
    {
      "id": "145. Binary Tree Postorder Traversal",
      "code": "class Solution:\n  def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n    ans = []\n\n    def postorder(root: Optional[TreeNode]) -> None:\n      if not root:\n        return\n\n      postorder(root.left)\n      postorder(root.right)\n      ans.append(root.val)\n\n    postorder(root)\n    return ans\n"
    }
  ],
  [
    {
      "id": "146. LRU Cache",
      "code": "class Node:\n  def __init__(self, key: int, value: int):\n    self.key = key\n    self.value = value\n    self.prev = None\n    self.next = None\n\n\n class LRUCache:\n  def __init__(self, capacity: int):\n    self.capacity = capacity\n    self.keyToNode = {}\n    self.head = Node(-1, -1)\n    self.tail = Node(-1, -1)\n    self.join(self.head, self.tail)\n\n  def get(self, key: int) -> int:\n    if key not in self.keyToNode:\n      return -1\n\n    node = self.keyToNode[key]\n    self.remove(node)\n    self.moveToHead(node)\n    return node.value\n\n  def put(self, key: int, value: int) -> None:\n    if key in self.keyToNode:\n      node = self.keyToNode[key]\n      node.value = value\n      self.remove(node)\n      self.moveToHead(node)\n      return\n\n    if len(self.keyToNode) == self.capacity:\n      lastNode = self.tail.prev\n      del self.keyToNode[lastNode.key]\n      self.remove(lastNode)\n\n    self.moveToHead(Node(key, value))\n    self.keyToNode[key] = self.head.next\n\n  def join(self, node1: Node, node2: Node):\n    node1.next = node2\n    node2.prev = node1\n\n  def moveToHead(self, node: Node):\n    self.join(node, self.head.next)\n    self.join(self.head, node)\n\n  def remove(self, node: Node):\n    self.join(node.prev, node.next)\n"
    }
  ],
  [
    {
      "id": "147. Insertion Sort List",
      "code": "class Solution:\n  def insertionSortList(self, head: ListNode) -> ListNode:\n    dummy = ListNode(0)\n    curr = head\n\n    while curr:\n      prev = dummy\n      while prev.next and prev.next.val < curr.val:\n        prev = prev.next\n      next = curr.next\n      curr.next = prev.next\n      prev.next = curr\n      curr = next\n\n    return dummy.next\n"
    }
  ],
  [
    {
      "id": "148. Sort List",
      "code": "class Solution:\n  def sortList(self, head: ListNode) -> ListNode:\n    def split(head: ListNode, k: int) -> ListNode:\n      while k > 1 and head:\n        head = head.next\n        k -= 1\n      rest = head.next if head else None\n      if head:\n        head.next = None\n      return rest\n\n    def merge(l1: ListNode, l2: ListNode) -> tuple:\n      dummy = ListNode(0)\n      tail = dummy\n\n      while l1 and l2:\n        if l1.val > l2.val:\n          l1, l2 = l2, l1\n        tail.next = l1\n        l1 = l1.next\n        tail = tail.next\n      tail.next = l1 if l1 else l2\n      while tail.next:\n        tail = tail.next\n\n      return dummy.next, tail\n\n    length = 0\n    curr = head\n    while curr:\n      length += 1\n      curr = curr.next\n\n    dummy = ListNode(0, head)\n\n    k = 1\n    while k < length:\n      curr = dummy.next\n      tail = dummy\n      while curr:\n        l = curr\n        r = split(l, k)\n        curr = split(r, k)\n        mergedHead, mergedTail = merge(l, r)\n        tail.next = mergedHead\n        tail = mergedTail\n      k *= 2\n\n    return dummy.next\n"
    }
  ],
  [
    {
      "id": "149. Max Points on a Line",
      "code": "class Solution:\n  def maxPoints(self, points: List[List[int]]) -> int:\n    ans = 0\n\n    def gcd(a: int, b: int) -> int:\n      return a if b == 0 else gcd(b, a % b)\n\n    def getSlope(p: List[int], q: List[int]) -> Tuple[int, int]:\n      dx = p[0] - q[0]\n      dy = p[1] - q[1]\n      if dx == 0:\n        return (0, p[0])\n      if dy == 0:\n        return (p[1], 0)\n      d = gcd(dx, dy)\n      return (dx // d, dy // d)\n\n    for i, p in enumerate(points):\n      slopeCount = collections.defaultdict(int)\n      samePoints = 1\n      maxPoints = 0\n      for j in range(i + 1, len(points)):\n        q = points[j]\n        if p == q:\n          samePoints += 1\n        else:\n          slope = getSlope(p, q)\n          slopeCount[slope] += 1\n          maxPoints = max(maxPoints, slopeCount[slope])\n      ans = max(ans, samePoints + maxPoints)\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "150. Evaluate Reverse Polish Notation",
      "code": "class Solution:\n  def evalRPN(self, tokens: List[str]) -> int:\n    stack = []\n    operators = {\n        '+': lambda a, b: a + b,\n        '-': lambda a, b: a - b,\n        '*': lambda a, b: a * b,\n        '/': lambda a, b: int(a / b),\n    }\n\n    for token in tokens:\n      if token in operators:\n        b = stack.pop()\n        a = stack.pop()\n        stack.append(operators[token](a, b))\n      else:\n        stack.append(int(token))\n\n    return stack[0]\n"
    }
  ],
  [
    {
      "id": "151. Reverse Words in a String",
      "code": "class Solution:\n  def reverseWords(self, s: str) -> str:\n    return ' '.join(reversed(s.split()))\n"
    }
  ],
  [
    {
      "id": "152. Maximum Product Subarray",
      "code": "class Solution:\n  def maxProduct(self, nums: List[int]) -> int:\n    ans = nums[0]\n    prevMin = nums[0]\n    prevMax = nums[0]\n\n    for i in range(1, len(nums)):\n      mini = prevMin * nums[i]\n      maxi = prevMax * nums[i]\n      prevMin = min(nums[i], mini, maxi)\n      prevMax = max(nums[i], mini, maxi)\n      ans = max(ans, prevMax)\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "153. Find Minimum in Rotated Sorted Array",
      "code": "class Solution:\n  def findMin(self, nums: List[int]) -> int:\n    l = 0\n    r = len(nums) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if nums[m] < nums[r]:\n        r = m\n      else:\n        l = m + 1\n\n    return nums[l]\n"
    }
  ],
  [
    {
      "id": "154. Find Minimum in Rotated Sorted Array II",
      "code": "class Solution:\n  def findMin(self, nums: List[int]) -> int:\n    l = 0\n    r = len(nums) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if nums[m] == nums[r]:\n        r -= 1\n      elif nums[m] < nums[r]:\n        r = m\n      else:\n        l = m + 1\n\n    return nums[l]\n"
    }
  ],
  [
    {
      "id": "155. Min Stack",
      "code": "class MinStack:\n  def __init__(self):\n    self.stack = []\n\n  def push(self, x: int) -> None:\n    mini = x if not self.stack else min(self.stack[-1][1], x)\n    self.stack.append([x, mini])\n\n  def pop(self) -> None:\n    self.stack.pop()\n\n  def top(self) -> int:\n    return self.stack[-1][0]\n\n  def getMin(self) -> int:\n    return self.stack[-1][1]\n"
    }
  ],
  [
    {
      "id": "156. Binary Tree Upside Down",
      "code": "class Solution:\n  def upsideDownBinaryTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n    if not root or not root.left:\n      return root\n\n    newRoot = self.upsideDownBinaryTree(root.left)\n    root.left.left = root.right  # 2's left = 3 (root's right)\n    root.left.right = root  # 2's right = 1 (root)\n    root.left = None\n    root.right = None\n    return newRoot\n"
    }
  ],
  null,
  null,
  [
    {
      "id": "159. Longest Substring with At Most Two Distinct Characters",
      "code": "class Solution:\n  def lengthOfLongestSubstringTwoDistinct(self, s: str) -> int:\n    ans = 0\n    distinct = 0\n    count = [0] * 128\n\n    l = 0\n    for r, c in enumerate(s):\n      count[ord(c)] += 1\n      if count[ord(c)] == 1:\n        distinct += 1\n      while distinct == 3:\n        count[ord(s[l])] -= 1\n        if count[ord(s[l])] == 0:\n          distinct -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "160. Intersection of Two Linked Lists",
      "code": "class Solution:\n  def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n    a = headA\n    b = headB\n\n    while a != b:\n      a = a.next if a else headB\n      b = b.next if b else headA\n\n    return a\n"
    }
  ],
  [
    {
      "id": "161. One Edit Distance",
      "code": "class Solution:\n  def isOneEditDistance(self, s: str, t: str) -> bool:\n    m = len(s)\n    n = len(t)\n    if m > n:  # Make sure len(s) <= len(t)\n          return self.isOneEditDistance(t, s)\n\n    for i in range(m):\n      if s[i] != t[i]:\n        if m == n:\n        return s[i + 1:] == t[i + 1:]\n    return s[i:] == t[i + 1:]\n return m + 1 == n\n"
    }
  ],
  [
    {
      "id": "162. Find Peak Element",
      "code": "class Solution:\n  def findPeakElement(self, nums: List[int]) -> int:\n    l = 0\n    r = len(nums) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if nums[m] >= nums[m + 1]:\n        r = m\n      else:\n        l = m + 1\n\n    return l\n"
    }
  ],
  [
    {
      "id": "163. Missing Ranges",
      "code": "class Solution:\n  def findMissingRanges(self, nums: List[int], lower: int, upper: int) -> List[str]:\n    def getRange(lo: int, hi: int) -> str:\n      if lo == hi:\n        return str(lo)\n      return str(lo) + '->' + str(hi)\n\n    if not nums:\n      return [getRange(lower, upper)]\n\n    ans = []\n\n    if nums[0] > lower:\n      ans.append(getRange(lower, nums[0] - 1))\n\n    for prev, curr in zip(nums, nums[1:]):\n      if curr > prev + 1:\n        ans.append(getRange(prev + 1, curr - 1))\n\n    if nums[-1] < upper:\n      ans.append(getRange(nums[-1] + 1, upper))\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "164. Maximum Gap",
      "code": "class Bucket:\n  def __init__(self, mini: int, maxi: int):\n    self.mini = mini\n    self.maxi = maxi\n\n\n class Solution:\n  def maximumGap(self, nums: List[int]) -> int:\n    if len(nums) < 2:\n      return 0\n\n    mini = min(nums)\n    maxi = max(nums)\n    if mini == maxi:\n      return 0\n\n    gap = math.ceil((maxi - mini) / (len(nums) - 1))\n    bucketSize = (maxi - mini) // gap + 1\n    buckets = [Bucket(math.inf, -math.inf) for _ in range(bucketSize)]\n\n    for num in nums:\n      i = (num - mini) // gap\n      buckets[i].mini = min(buckets[i].mini, num)\n      buckets[i].maxi = max(buckets[i].maxi, num)\n\n    ans = 0\n    prevMax = mini\n\n    for bucket in buckets:\n      if bucket.mini == math.inf:\n        continue  # Empty bucket\n      ans = max(ans, bucket.mini - prevMax)\n      prevMax = bucket.maxi\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "165. Compare Version Numbers",
      "code": "class Solution:\n  def compareVersion(self, version1: str, version2: str) -> int:\n    levels1 = version1.split('.')\n    levels2 = version2.split('.')\n    length = max(len(levels1), len(levels2))\n\n    for i in range(length):\n      v1 = int(levels1[i]) if i < len(levels1) else 0\n      v2 = int(levels2[i]) if i < len(levels2) else 0\n      if v1 < v2:\n        return -1\n      if v1 > v2:\n        return 1\n\n    return 0\n"
    }
  ],
  [
    {
      "id": "166. Fraction to Recurring Decimal",
      "code": "class Solution:\n  def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n    if numerator == 0:\n      return '0'\n\n    ans = ''\n\n    if (numerator < 0) ^ (denominator < 0):\n      ans += '-'\n\n    numerator = abs(numerator)\n    denominator = abs(denominator)\n    ans += str(numerator // denominator)\n\n    if numerator % denominator == 0:\n      return ans\n\n    ans += '.'\n    dict = {}\n\n    remainder = numerator % denominator\n    while remainder:\n      if remainder in dict:\n        ans = ans[:dict[remainder]] + '(' + ans[dict[remainder]:] + ')'\n        break\n      dict[remainder] = len(ans)\n      remainder *= 10\n      ans += str(remainder // denominator)\n      remainder %= denominator\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "167. Two Sum II - Input Array Is Sorted",
      "code": "class Solution:\n  def twoSum(self, numbers: List[int], target: int) -> List[int]:\n    l = 0\n    r = len(numbers) - 1\n\n    while l < r:\n      summ = numbers[l] + numbers[r]\n      if summ == target:\n        return [l + 1, r + 1]\n      if summ < target:\n        l += 1\n      else:\n        r -= 1\n"
    }
  ],
  [
    {
      "id": "168. Excel Sheet Column Title",
      "code": "class Solution:\n  def convertToTitle(self, n: int) -> str:\n    return self.convertToTitle((n - 1) // 26) + \\\n        chr(ord('A') + (n - 1) % 26) if n else ''\n"
    }
  ],
  [
    {
      "id": "169. Majority Element",
      "code": "class Solution:\n  def majorityElement(self, nums: List[int]) -> int:\n    ans = None\n    count = 0\n\n    for num in nums:\n      if count == 0:\n        ans = num\n      count += (1 if num == ans else -1)\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "170. Two Sum III - Data structure design",
      "code": "class TwoSum:\n  def __init__(self):\n    self.count = collections.Counter()\n\n  def add(self, number: int) -> None:\n    self.count[number] += 1\n\n  def find(self, value: int) -> bool:\n    for key, freq in self.count.items():\n      remain = value - key\n      if key == remain and freq > 1:\n        return True\n      if key != remain and remain in self.count:\n        return True\n\n    return False\n"
    }
  ],
  [
    {
      "id": "171. Excel Sheet Column Number",
      "code": "class Solution:\n  def titleToNumber(self, s: str) -> int:\n    ans = 0\n\n    for c in s:\n      ans = ans * 26 + ord(c) - ord('@')\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "172. Factorial Trailing Zeroes",
      "code": "class Solution:\n  def trailingZeroes(self, n: int) -> int:\n    return 0 if n == 0 else n // 5 + self.trailingZeroes(n // 5)\n"
    }
  ],
  [
    {
      "id": "173. Binary Search Tree Iterator",
      "code": "class BSTIterator:\n  def __init__(self, root: Optional[TreeNode]):\n    self.stack = []\n    self.pushLeftsUntilNone(root)\n\n  def next(self) -> int:\n    root = self.stack.pop()\n    self.pushLeftsUntilNone(root.right)\n    return root.val\n\n  def hasNext(self) -> bool:\n    return self.stack\n\n  def pushLeftsUntilNone(self, root: Optional[TreeNode]):\n    while root:\n      self.stack.append(root)\n      root = root.left\n"
    }
  ],
  [
    {
      "id": "174. Dungeon Game",
      "code": "class Solution:\n  def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\n    m = len(dungeon)\n    n = len(dungeon[0])\n    dp = [math.inf] * (n + 1)\n    dp[n - 1] = 1\n\n    for i in reversed(range(m)):\n      for j in reversed(range(n)):\n        dp[j] = min(dp[j], dp[j + 1]) - dungeon[i][j]\n        dp[j] = max(dp[j], 1)\n\n    return dp[0]\n"
    }
  ],
  null,
  null,
  null,
  null,
  [
    {
      "id": "179. Largest Number",
      "code": "class LargerStrKey(str):\n  def __lt__(x: str, y: str) -> bool:\n    return x + y > y + x\n\n\n class Solution:\n  def largestNumber(self, nums: List[int]) -> str:\n    return ''.join(sorted(map(str, nums), key=LargerStrKey)).lstrip('0') or '0'\n"
    }
  ],
  null,
  null,
  null,
  null,
  null,
  null,
  [
    {
      "id": "186. Reverse Words in a String II",
      "code": "class Solution:\n  def reverseWords(self, s: List[str]) -> None:\n    def reverse(l: int, r: int) -> None:\n      while l < r:\n        s[l], s[r] = s[r], s[l]\n        l += 1\n        r -= 1\n\n    def reverseWords(n: int) -> None:\n      i = 0\n      j = 0\n\n      while i < n:\n        while i < j or (i < n and s[i] == ' '):  # Skip spaces\n          i += 1\n        while j < i or (j < n and s[j] != ' '):  # Skip non spaces\n          j += 1\n        reverse(i, j - 1)  # Reverse the word\n\n    reverse(0, len(s) - 1)  # Reverse the whole string\n    reverseWords(len(s))  # Reverse each word\n"
    }
  ],
  [
    {
      "id": "187. Repeated DNA Sequences",
      "code": "class Solution:\n  def findRepeatedDnaSequences(self, s: str) -> List[str]:\n    ans = set()\n    seen = set()\n\n    for i in range(len(s) - 9):\n      seq = s[i:i + 10]\n      if seq in seen:\n        ans.add(seq)\n      seen.add(seq)\n\n    return list(ans)\n"
    }
  ],
  [
    {
      "id": "188. Best Time to Buy and Sell Stock IV",
      "code": "class Solution:\n  def maxProfit(self, k: int, prices: List[int]) -> int:\n    if k >= len(prices) // 2:\n      sell = 0\n      hold = -math.inf\n\n      for price in prices:\n        sell = max(sell, hold + price)\n        hold = max(hold, sell - price)\n\n      return sell\n\n    sell = [0] * (k + 1)\n    hold = [-math.inf] * (k + 1)\n\n    for price in prices:\n      for i in range(k, 0, -1):\n        sell[i] = max(sell[i], hold[i] + price)\n        hold[i] = max(hold[i], sell[i - 1] - price)\n\n    return sell[k]\n"
    }
  ],
  [
    {
      "id": "189. Rotate Array",
      "code": "class Solution:\n  def rotate(self, nums: List[int], k: int) -> None:\n    k %= len(nums)\n    self.reverse(nums, 0, len(nums) - 1)\n    self.reverse(nums, 0, k - 1)\n    self.reverse(nums, k, len(nums) - 1)\n\n  def reverse(self, nums: List[int], l: int, r: int) -> None:\n    while l < r:\n      nums[l], nums[r] = nums[r], nums[l]\n      l += 1\n      r -= 1\n"
    }
  ],
  [
    {
      "id": "190. Reverse Bits",
      "code": "class Solution:\n  def reverseBits(self, n: int) -> int:\n    ans = 0\n\n    for i in range(32):\n      if n >> i & 1:\n        ans |= 1 << 31 - i\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "191. Number of 1 Bits",
      "code": "class Solution:\n  def hammingWeight(self, n: int) -> int:\n    ans = 0\n\n    for i in range(32):\n      if (n >> i) & 1:\n        ans += 1\n\n    return ans\n"
    }
  ],
  null,
  null,
  null,
  null,
  null,
  null,
  [
    {
      "id": "198. House Robber",
      "code": "class Solution:\n  def rob(self, nums: List[int]) -> int:\n    if not nums:\n      return 0\n    if len(nums) == 1:\n      return nums[0]\n\n    # dp[i]: = max money of robbing nums[0..i]\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[-1]\n"
    }
  ],
  [
    {
      "id": "199. Binary Tree Right Side View",
      "code": "class Solution:\n  def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n    if not root:\n      return []\n\n    ans = []\n    q = collections.deque([root])\n\n    while q:\n      size = len(q)\n      for i in range(size):\n        root = q.popleft()\n        if i == size - 1:\n          ans.append(root.val)\n        if root.left:\n          q.append(root.left)\n        if root.right:\n          q.append(root.right)\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "200. Number of Islands",
      "code": "class Solution:\n  def numIslands(self, grid: List[List[str]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    dirs = [0, 1, 0, -1, 0]\n\n    def bfs(r, c):\n      q = collections.deque([(r, c)])\n      grid[r][c] = '2'  # Mark '2' as visited\n      while q:\n        i, j = q.popleft()\n        for k in range(4):\n          x = i + dirs[k]\n          y = j + dirs[k + 1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if grid[x][y] != '1':\n            continue\n          q.append((x, y))\n          grid[x][y] = '2'  # Mark '2' as visited\n\n    ans = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == '1':\n          bfs(i, j)\n          ans += 1\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "201. Bitwise AND of Numbers Range",
      "code": "class Solution:\n  def rangeBitwiseAnd(self, m: int, n: int) -> int:\n    return self.rangeBitwiseAnd(m >> 1, n >> 1) << 1 if m < n else m\n"
    }
  ],
  [
    {
      "id": "202. Happy Number",
      "code": "class Solution:\n  def isHappy(self, n: int) -> bool:\n    def squaredSum(n: int) -> bool:\n      summ = 0\n      while n:\n        summ += pow(n % 10, 2)\n        n //= 10\n      return summ\n\n    slow = squaredSum(n)\n    fast = squaredSum(squaredSum(n))\n\n    while slow != fast:\n      slow = squaredSum(slow)\n      fast = squaredSum(squaredSum(fast))\n\n    return slow == 1\n"
    }
  ],
  [
    {
      "id": "203. Remove Linked List Elements",
      "code": "class Solution:\n  def removeElements(self, head: ListNode, val: int) -> ListNode:\n    dummy = ListNode(0, head)\n    prev = dummy\n\n    while head:\n      if head.val != val:\n        prev.next = head\n        prev = prev.next\n      head = head.next\n    prev.next = None\n\n    return dummy.next\n"
    }
  ],
  [
    {
      "id": "204. Count Primes",
      "code": "class Solution:\n  def countPrimes(self, n: int) -> int:\n    if n <= 2:\n      return 0\n    return sum(self._sieveEratosthenes(n))\n\n  def _sieveEratosthenes(self, n: int) -> List[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime\n"
    }
  ],
  [
    {
      "id": "205. Isomorphic Strings",
      "code": "class Solution:\n  def isIsomorphic(self, s: str, t: str) -> bool:\n    return [*map(s.index, s)] == [*map(t.index, t)]\n"
    }
  ],
  [
    {
      "id": "206. Reverse Linked List",
      "code": "class Solution:\n  def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n    if not head or not head.next:\n      return head\n\n    newHead = self.reverseList(head.next)\n    head.next.next = head\n    head.next = None\n    return newHead\n"
    }
  ],
  [
    {
      "id": "207. Course Schedule",
      "code": "from enum import Enum\n\n\n class State(Enum):\n  kInit = 0\n  kVisiting = 1\n  kVisited = 2\n\n\n class Solution:\n  def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n    graph = [[] for _ in range(numCourses)]\n    state = [State.kInit] * numCourses\n\n    for a, b in prerequisites:\n      graph[b].append(a)\n\n    def hasCycle(u: int) -> bool:\n      if state[u] == State.kVisiting:\n        return True\n      if state[u] == State.kVisited:\n        return False\n\n      state[u] = State.kVisiting\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      state[u] = State.kVisited\n\n      return False\n\n    return not any(hasCycle(i) for i in range(numCourses))\n"
    }
  ],
  [
    {
      "id": "208. Implement Trie (Prefix Tree)",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: Dict[str, TrieNode] = collections.defaultdict(TrieNode)\n    self.isWord = False\n\n\n class Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      if c not in node.children:\n        node.children[c] = TrieNode()\n      node = node.children[c]\n    node.isWord = True\n\n  def search(self, word: str) -> bool:\n    node: TrieNode = self._find(word)\n    return node and node.isWord\n\n  def startsWith(self, prefix: str) -> bool:\n    return self._find(prefix)\n\n  def _find(self, prefix: str) -> Optional[TrieNode]:\n    node: TrieNode = self.root\n    for c in prefix:\n      if c not in node.children:\n        return None\n      node = node.children[c]\n    return node\n"
    }
  ],
  [
    {
      "id": "209. Minimum Size Subarray Sum",
      "code": "class Solution:\n  def minSubArrayLen(self, s: int, nums: List[int]) -> int:\n    ans = math.inf\n    summ = 0\n    j = 0\n\n    for i, num in enumerate(nums):\n      summ += num\n      while summ >= s:\n        ans = min(ans, i - j + 1)\n        summ -= nums[j]\n        j += 1\n\n    return ans if ans != math.inf else 0\n"
    }
  ],
  [
    {
      "id": "210. Course Schedule II",
      "code": "from enum import Enum\n\n\n class State(Enum):\n  kInit = 0\n  kVisiting = 1\n  kVisited = 2\n\n\n class Solution:\n  def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n    ans = []\n    graph = [[] for _ in range(numCourses)]\n    state = [State.kInit] * numCourses\n\n    for v, u in prerequisites:\n      graph[u].append(v)\n\n    def hasCycle(u: int) -> bool:\n      if state[u] == State.kVisiting:\n        return True\n      if state[u] == State.kVisited:\n        return False\n\n      state[u] = State.kVisiting\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      state[u] = State.kVisited\n      ans.append(u)\n\n      return False\n\n    if any(hasCycle(i) for i in range(numCourses)):\n      return []\n\n    return ans[::-1]\n"
    }
  ],
  [
    {
      "id": "211. Design Add and Search Words Data Structure",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: Dict[str, TrieNode] = collections.defaultdict(TrieNode)\n    self.isWord = False\n\n\n class WordDictionary:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def addWord(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      if c not in node.children:\n        node.children[c] = TrieNode()\n      node = node.children[c]\n    node.isWord = True\n\n  def search(self, word: str) -> bool:\n    return self._dfs(word, 0, self.root)\n\n  def _dfs(self, word: str, s: int, node: TrieNode) -> bool:\n    if s == len(word):\n      return node.isWord\n    if word[s] != '.':\n      next: TrieNode = node.children[word[s]]\n      return self._dfs(word, s + 1, next) if next else False\n\n    for c in string.ascii_lowercase:\n      if c in node.children and self._dfs(word, s + 1, node.children[c]):\n        return True\n\n    return False\n"
    }
  ],
  [
    {
      "id": "212. Word Search II",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: Dict[str, TrieNode] = collections.defaultdict(TrieNode)\n    self.word: Optional[str] = None\n\n\n class Solution:\n  def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n    m = len(board)\n    n = len(board[0])\n    ans = []\n    root = TrieNode()\n\n    def insert(word: str) -> None:\n      node = root\n      for c in word:\n        if c not in node.children:\n          node.children[c] = TrieNode()\n        node = node.children[c]\n      node.word = word\n\n    for word in words:\n      insert(word)\n\n    def dfs(i: int, j: int, node: TrieNode) -> None:\n      if i < 0 or i == m or j < 0 or j == n:\n        return\n      if board[i][j] == '*':\n        return\n\n      c = board[i][j]\n      if c not in node.children:\n        return\n\n      child = node.children[c]\n      if child.word:\n        ans.append(child.word)\n        child.word = None\n\n      board[i][j] = '*'\n      dfs(i + 1, j, child)\n      dfs(i - 1, j, child)\n      dfs(i, j + 1, child)\n      dfs(i, j - 1, child)\n      board[i][j] = c\n\n    for i in range(m):\n      for j in range(n):\n        dfs(i, j, root)\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "213. House Robber II",
      "code": "class Solution:\n  def rob(self, nums: List[int]) -> int:\n    if not nums:\n      return 0\n    if len(nums) < 2:\n      return nums[0]\n\n    def rob(l: int, r: int) -> int:\n      dp1 = 0\n      dp2 = 0\n\n      for i in range(l, r + 1):\n        temp = dp1\n        dp1 = max(dp1, dp2 + nums[i])\n        dp2 = temp\n\n      return dp1\n\n    return max(rob(0, len(nums) - 2),\n               rob(1, len(nums) - 1))\n"
    }
  ],
  [
    {
      "id": "214. Shortest Palindrome",
      "code": "class Solution:\n  def shortestPalindrome(self, s: str) -> str:\n    t = s[::-1]\n\n    for i in range(len(t)):\n      if s.startswith(t[i:]):\n        return t[:i] + s\n\n    return t + s\n"
    }
  ],
  [
    {
      "id": "215. Kth Largest Element in an Array",
      "code": "class Solution:\n  def findKthLargest(self, nums: List[int], k: int) -> int:\n    minHeap = []\n\n    for num in nums:\n      heapq.heappush(minHeap, num)\n      if len(minHeap) > k:\n        heapq.heappop(minHeap)\n\n    return minHeap[0]\n"
    }
  ],
  [
    {
      "id": "216. Combination Sum III",
      "code": "class Solution:\n  def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n    ans = []\n\n    def dfs(k: int, n: int, s: int, path: List[int]) -> None:\n      if k == 0 and n == 0:\n        ans.append(path)\n        return\n      if k == 0 or n < 0:\n        return\n\n      for i in range(s, 10):\n        dfs(k - 1, n - i, i + 1, path + [i])\n\n    dfs(k, n, 1, [])\n    return ans\n"
    }
  ],
  [
    {
      "id": "217. Contains Duplicate",
      "code": "class Solution:\n  def containsDuplicate(self, nums: List[int]) -> bool:\n    return len(nums) != len(set(nums))\n"
    }
  ],
  [
    {
      "id": "218. The Skyline Problem",
      "code": "class Solution:\n  def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n    n = len(buildings)\n    if n == 0:\n      return []\n    if n == 1:\n      left, right, height = buildings[0]\n      return [[left, height], [right, 0]]\n\n    left = self.getSkyline(buildings[:n // 2])\n    right = self.getSkyline(buildings[n // 2:])\n    return self._merge(left, right)\n\n  def _merge(self, left: List[List[int]], right: List[List[int]]) -> List[List[int]]:\n    ans = []\n    i = 0  # left's index\n    j = 0  # right's index\n    leftY = 0\n    rightY = 0\n\n    while i < len(left) and j < len(right):\n      # Choose the powith smaller x\n      if left[i][0] < right[j][0]:\n        leftY = left[i][1]  # Update the ongoing leftY\n        self._addPoint(ans, left[i][0], max(left[i][1], rightY))\n        i += 1\n      else:\n        rightY = right[j][1]  # Update the ongoing rightY\n        self._addPoint(ans, right[j][0], max(right[j][1], leftY))\n        j += 1\n\n    while i < len(left):\n      self._addPoint(ans, left[i][0], left[i][1])\n      i += 1\n\n    while j < len(right):\n      self._addPoint(ans, right[j][0], right[j][1])\n      j += 1\n\n    return ans\n\n  def _addPoint(self, ans: List[List[int]], x: int, y: int) -> None:\n    if ans and ans[-1][0] == x:\n      ans[-1][1] = y\n      return\n    if ans and ans[-1][1] == y:\n      return\n    ans.append([x, y])\n"
    }
  ],
  [
    {
      "id": "219. Contains Duplicate II",
      "code": "class Solution:\n  def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n    seen = set()\n\n    for i, num in enumerate(nums):\n      if i > k:\n        seen.remove(nums[i - k - 1])\n      if num in seen:\n        return True\n      seen.add(num)\n\n    return False\n"
    }
  ],
  null,
  [
    {
      "id": "221. Maximal Square",
      "code": "class Solution:\n  def maximalSquare(self, matrix: List[List[str]]) -> int:\n    m = len(matrix)\n    n = len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    maxLength = 0\n\n    for i in range(m):\n      for j in range(n):\n        if i == 0 or j == 0 or matrix[i][j] == '0':\n          dp[i][j] = 1 if matrix[i][j] == '1' else 0\n        else:\n          dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1]\n                         [j], dp[i][j - 1]) + 1\n        maxLength = max(maxLength, dp[i][j])\n\n    return maxLength * maxLength\n"
    }
  ],
  [
    {
      "id": "222. Count Complete Tree Nodes",
      "code": "class Solution:\n  def countNodes(self, root: Optional[TreeNode]) -> int:\n    if not root:\n      return 0\n    return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n"
    }
  ],
  [
    {
      "id": "223. Rectangle Area",
      "code": "class Solution:\n  def computeArea(self, A: int, B: int, C: int, D: int, E: int, F: int, G: int, H: int) -> int:\n    x = min(C, G) - max(A, E) if max(A, E) < min(C, G) else 0\n    y = min(D, H) - max(B, F) if max(B, F) < min(D, H) else 0\n    return (C - A) * (D - B) + (G - E) * (H - F) - x * y\n"
    }
  ],
  [
    {
      "id": "224. Basic Calculator",
      "code": "class Solution:\n  def calculate(self, s: str) -> int:\n    ans = 0\n    num = 0\n    sign = 1\n    stack = [sign]  # stack[-1]: current env's sign\n\n    for c in s:\n      if c.isdigit():\n        num = num * 10 + (ord(c) - ord('0'))\n      elif c == '(':\n        stack.append(sign)\n      elif c == ')':\n        stack.pop()\n      elif c == '+' or c == '-':\n        ans += sign * num\n        sign = (1 if c == '+' else -1) * stack[-1]\n        num = 0\n\n    return ans + sign * num\n"
    }
  ],
  [
    {
      "id": "225. Implement Stack using Queues",
      "code": "class MyStack:\n  def __init__(self):\n    self.q = collections.deque()\n\n  def push(self, x: int) -> None:\n    self.q.append(x)\n    for _ in range(len(self.q) - 1):\n      self.q.append(self.q.popleft())\n\n  def pop(self) -> int:\n    return self.q.popleft()\n\n  def top(self) -> int:\n    return self.q[0]\n\n  def empty(self) -> bool:\n    return not self.q\n"
    }
  ],
  [
    {
      "id": "226. Invert Binary Tree",
      "code": "class Solution:\n  def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n    if not root:\n      return None\n\n    left = root.left\n    right = root.right\n    root.left = self.invertTree(right)\n    root.right = self.invertTree(left)\n    return root\n"
    }
  ],
  [
    {
      "id": "227. Basic Calculator II",
      "code": "class Solution:\n  def calculate(self, s: str) -> int:\n    ans = 0\n    prevNum = 0\n    currNum = 0\n    op = '+'\n\n    for i, c in enumerate(s):\n      if c.isdigit():\n        currNum = currNum * 10 + int(c)\n      if not c.isdigit() and c != ' ' or i == len(s) - 1:\n        if op == '+' or op == '-':\n          ans += prevNum\n          prevNum = currNum if op == '+' else -currNum\n        elif op == '*':\n          prevNum = prevNum * currNum\n        elif op == '/':\n          if prevNum < 0:\n            prevNum = math.ceil(prevNum / currNum)\n          else:\n            prevNum = prevNum // currNum\n        op = c\n        currNum = 0\n\n    return ans + prevNum\n"
    }
  ],
  [
    {
      "id": "228. Summary Ranges",
      "code": "class Solution:\n  def summaryRanges(self, nums: List[int]) -> List[str]:\n    ans = []\n\n    i = 0\n    while i < len(nums):\n      begin = nums[i]\n      while i < len(nums) - 1 and nums[i] == nums[i + 1] - 1:\n        i += 1\n      end = nums[i]\n      if begin == end:\n        ans.append(str(begin))\n      else:\n        ans.append(str(begin) + \"->\" + str(end))\n      i += 1\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "229. Majority Element II",
      "code": "class Solution:\n  def majorityElement(self, nums: List[int]) -> List[int]:\n    ans1 = 0\n    ans2 = 1\n    count1 = 0\n    count2 = 0\n\n    for num in nums:\n      if num == ans1:\n        count1 += 1\n      elif num == ans2:\n        count2 += 1\n      elif count1 == 0:\n        ans1 = num\n        count1 = 1\n      elif count2 == 0:\n        ans2 = num\n        count2 = 1\n      else:\n        count1 -= 1\n        count2 -= 1\n\n    return [ans for ans in (ans1, ans2) if nums.count(ans) > len(nums) // 3]\n"
    }
  ],
  [
    {
      "id": "230. Kth Smallest Element in a BST",
      "code": "class Solution:\n  def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n    def countNodes(root: Optional[TreeNode]) -> int:\n      if not root:\n        return 0\n      return 1 + countNodes(root.left) + countNodes(root.right)\n\n    leftCount = countNodes(root.left)\n\n    if leftCount == k - 1:\n      return root.val\n    if leftCount >= k:\n      return self.kthSmallest(root.left, k)\n    return self.kthSmallest(root.right, k - 1 - leftCount)  # LeftCount < k\n"
    }
  ],
  [
    {
      "id": "231. Power of Two",
      "code": "class Solution:\n  def isPowerOfTwo(self, n: int) -> bool:\n    return False if n < 0 else bin(n).count('1') == 1\n"
    }
  ],
  [
    {
      "id": "232. Implement Queue using Stacks",
      "code": "class MyQueue:\n  def __init__(self):\n    self.input = []\n    self.output = []\n\n  def push(self, x: int) -> None:\n    self.input.append(x)\n\n  def pop(self) -> int:\n    self.peek()\n    return self.output.pop()\n\n  def peek(self) -> int:\n    if not self.output:\n      while self.input:\n        self.output.append(self.input.pop())\n    return self.output[-1]\n\n  def empty(self) -> bool:\n    return not self.input and not self.output\n"
    }
  ],
  [
    {
      "id": "233. Number of Digit One",
      "code": "class Solution:\n  def countDigitOne(self, n: int) -> int:\n    ans = 0\n\n    pow10 = 1\n    while pow10 <= n:\n      divisor = pow10 * 10\n      quotient = n // divisor\n      remainder = n % divisor\n      if quotient > 0:\n        ans += quotient * pow10\n      if remainder >= pow10:\n        ans += min(remainder - pow10 + 1, pow10)\n      pow10 *= 10\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "234. Palindrome Linked List",
      "code": "class Solution:\n  def isPalindrome(self, head: ListNode) -> bool:\n    def reverseList(head: ListNode) -> ListNode:\n      prev = None\n      curr = head\n\n      while curr:\n        next = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next\n\n      return prev\n\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n      slow = slow.next\n      fast = fast.next.next\n\n    if fast:\n      slow = slow.next\n    slow = reverseList(slow)\n\n    while slow:\n      if slow.val != head.val:\n        return False\n      slow = slow.next\n      head = head.next\n\n    return True\n"
    }
  ],
  [
    {
      "id": "235. Lowest Common Ancestor of a Binary Search Tree",
      "code": "class Solution:\n  def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n    if root.val > max(p.val, q.val):\n      return self.lowestCommonAncestor(root.left, p, q)\n    if root.val < min(p.val, q.val):\n      return self.lowestCommonAncestor(root.right, p, q)\n    return root\n"
    }
  ],
  [
    {
      "id": "236. Lowest Common Ancestor of a Binary Tree",
      "code": "class Solution:\n  def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n    if not root or root == p or root == q:\n      return root\n\n    l = self.lowestCommonAncestor(root.left, p, q)\n    r = self.lowestCommonAncestor(root.right, p, q)\n\n    if l and r:\n      return root\n    return l or r\n"
    }
  ],
  [
    {
      "id": "237. Delete Node in a Linked List",
      "code": "class Solution:\n  def deleteNode(self, node):\n    node.val = node.next.val\n    node.next = node.next.next\n"
    }
  ],
  [
    {
      "id": "238. Product of Array Except Self",
      "code": "class Solution:\n  def productExceptSelf(self, nums: List[int]) -> List[int]:\n    n = len(nums)\n    prefix = [1] * n  # Prefix product\n    suffix = [1] * n  # Suffix product\n\n    for i in range(1, n):\n      prefix[i] = prefix[i - 1] * nums[i - 1]\n\n    for i in reversed(range(n - 1)):\n      suffix[i] = suffix[i + 1] * nums[i + 1]\n\n    return [prefix[i] * suffix[i] for i in range(n)]\n"
    }
  ],
  [
    {
      "id": "239. Sliding Window Maximum",
      "code": "class Solution:\n  def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n    ans = []\n    q = collections.deque()  # Max queue\n\n    for i, num in enumerate(nums):\n      while q and q[-1] < num:\n        q.pop()\n      q.append(num)\n      if i >= k and nums[i - k] == q[0]:  # Out of bound\n        q.popleft()\n      if i >= k - 1:\n        ans.append(q[0])\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "240. Search a 2D Matrix II",
      "code": "class Solution:\n  def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n    r = 0\n    c = len(matrix[0]) - 1\n\n    while r < len(matrix) and c >= 0:\n      if matrix[r][c] == target:\n        return True\n      if target < matrix[r][c]:\n        c -= 1\n      else:\n        r += 1\n\n    return False\n"
    }
  ],
  [
    {
      "id": "241. Different Ways to Add Parentheses",
      "code": "class Solution:\n  @functools.lru_cache(None)\n  def diffWaysToCompute(self, expression: str) -> List[int]:\n    ans = []\n\n    for i, c in enumerate(expression):\n      if c in '+-*':\n        for a in self.diffWaysToCompute(expression[:i]):\n          for b in self.diffWaysToCompute(expression[i + 1:]):\n            ans.append(eval(str(a) + c + str(b)))\n\n    return ans or [int(expression)]\n"
    }
  ],
  [
    {
      "id": "242. Valid Anagram",
      "code": "class Solution:\n  def isAnagram(self, s: str, t: str) -> bool:\n    if len(s) != len(t):\n      return False\n\n    dict = collections.Counter(s)\n\n    for c in t:\n      dict[c] -= 1\n      if dict[c] < 0:\n        return False\n\n    return True\n"
    }
  ],
  [
    {
      "id": "243. Shortest Word Distance",
      "code": "class Solution:\n  def shortestDistance(self, wordsDict: List[str], word1: str, word2: str) -> int:\n    ans = len(wordsDict)\n    index1 = -1  # wordsDict[index1] == word1\n    index2 = -1  # wordsDict[index2] == word2\n\n    for i, word in enumerate(wordsDict):\n      if word == word1:\n        index1 = i\n        if index2 != -1:\n          ans = min(ans, index1 - index2)\n      if word == word2:\n        index2 = i\n        if index1 != -1:\n          ans = min(ans, index2 - index1)\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "244. Shortest Word Distance II",
      "code": "class WordDistance:\n  def __init__(self, wordsDict: List[str]):\n    self.wordToIndices = collections.defaultdict(list)\n    for i, word in enumerate(wordsDict):\n      self.wordToIndices[word].append(i)\n\n  def shortest(self, word1: str, word2: str) -> int:\n    indices1 = self.wordToIndices[word1]\n    indices2 = self.wordToIndices[word2]\n    ans = math.inf\n\n    i = 0\n    j = 0\n    while i < len(indices1) and j < len(indices2):\n      ans = min(ans, abs(indices1[i] - indices2[j]))\n      if indices1[i] < indices2[j]:\n        i += 1\n      else:\n        j += 1\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "245. Shortest Word Distance III",
      "code": "class Solution:\n  def shortestWordDistance(self, wordsDict: List[str], word1: str, word2: str) -> int:\n    isSame = word1 == word2\n    ans = math.inf\n    # If word1 == word2, index1 is the newest index\n    index1 = len(wordsDict)\n    # If word1 == word2, index2 is the previous index\n    index2 = -len(wordsDict)\n\n    for i, word in enumerate(wordsDict):\n      if word == word1:\n        if isSame:\n          index2 = index1\n        index1 = i\n      elif word == word2:\n        index2 = i\n      ans = min(ans, abs(index1 - index2))\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "246. Strobogrammatic Number",
      "code": "class Solution:\n  def isStrobogrammatic(self, num: str) -> bool:\n    rotated = ['0', '1', 'x', 'x', 'x',\n               'x', '9', 'x', '8', '6']\n    l = 0\n    r = len(num) - 1\n\n    while l <= r:\n      if num[l] != rotated[ord(num[r]) - ord('0')]:\n        return False\n      l += 1\n      r -= 1\n\n    return True\n"
    }
  ],
  [
    {
      "id": "247. Strobogrammatic Number II",
      "code": "class Solution:\n  def findStrobogrammatic(self, n: int) -> List[str]:\n    def helper(n: int, k: int) -> List[str]:\n      if n == 0:\n        return ['']\n      if n == 1:\n        return ['0', '1', '8']\n\n      ans = []\n\n      for inner in helper(n - 2, k):\n        if n < k:\n          ans.append('0' + inner + '0')\n        ans.append('1' + inner + '1')\n        ans.append('6' + inner + '9')\n        ans.append('8' + inner + '8')\n        ans.append('9' + inner + '6')\n\n      return ans\n\n    return helper(n, n)\n"
    }
  ],
  [
    {
      "id": "248. Strobogrammatic Number III",
      "code": "class Solution:\n  def strobogrammaticInRange(self, low: str, high: str) -> int:\n    pairs = [['0', '0'], ['1', '1'], ['6', '9'], ['8', '8'], ['9', '6']]\n    ans = 0\n\n    def dfs(s: List[chr], l: int, r: int) -> None:\n      nonlocal ans\n      if l > r:\n        if len(s) == len(low) and ''.join(s) < low:\n          return\n        if len(s) == len(high) and ''.join(s) > high:\n          return\n        ans += 1\n        return\n\n      for leftDigit, rightDigit in pairs:\n        if l == r and leftDigit != rightDigit:\n          continue\n        s[l] = leftDigit\n        s[r] = rightDigit\n        if len(s) > 1 and s[0] == '0':\n          continue\n        dfs(s, l + 1, r - 1)\n\n    for n in range(len(low), len(high) + 1):\n      dfs([' '] * n, 0, n - 1)\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "249. Group Shifted Strings",
      "code": "class Solution:\n  def groupStrings(self, strings: List[str]) -> List[List[str]]:\n    keyToStrings = collections.defaultdict(list)\n\n    # 'abc' . '11' because diff(a, b) = 1 and diff(b, c) = 1\n    def getKey(s: str) -> str:\n      key = ''\n\n      for i in range(1, len(s)):\n        diff = (ord(s[i]) - ord(s[i - 1]) + 26) % 26\n        key += str(diff) + ','\n\n      return key\n\n    for s in strings:\n      keyToStrings[getKey(s)].append(s)\n\n    return keyToStrings.values()\n"
    }
  ],
  [
    {
      "id": "250. Count Univalue Subtrees",
      "code": "class Solution:\n  def countUnivalSubtrees(self, root: Optional[TreeNode]) -> int:\n    ans = 0\n\n    def isUnival(root: Optional[TreeNode], val: int) -> bool:\n      nonlocal ans\n      if not root:\n        return True\n\n      if isUnival(root.left, root.val) & isUnival(root.right, root.val):\n        ans += 1\n        return root.val == val\n\n      return False\n\n    isUnival(root, math.inf)\n    return ans\n"
    }
  ],
  [
    {
      "id": "251. Flatten 2D Vector",
      "code": "class Vector2D:\n  def __init__(self, vec: List[List[int]]):\n    self.vec = []\n    self.i = 0\n\n    for A in vec:\n      self.vec += A\n\n  def next(self) -> int:\n    ans = self.vec[self.i]\n    self.i += 1\n    return ans\n\n  def hasNext(self) -> bool:\n    return self.i < len(self.vec)\n"
    }
  ],
  [
    {
      "id": "252. Meeting Rooms",
      "code": "class Solution:\n  def canAttendMeetings(self, intervals: List[List[int]]) -> bool:\n    intervals.sort()\n\n    for i in range(1, len(intervals)):\n      if intervals[i - 1][1] > intervals[i][0]:\n        return False\n\n    return True\n"
    }
  ],
  [
    {
      "id": "253. Meeting Rooms II",
      "code": "class Solution:\n  def minMeetingRooms(self, intervals: List[List[int]]) -> int:\n    minHeap = []  # Store end times of each room\n\n    for start, end in sorted(intervals):\n      if minHeap and start >= minHeap[0]:\n        heapq.heappop(minHeap)\n      heapq.heappush(minHeap, end)\n\n    return len(minHeap)\n"
    }
  ],
  [
    {
      "id": "254. Factor Combinations",
      "code": "class Solution:\n  def getFactors(self, n: int) -> List[List[int]]:\n    ans = []\n\n    def dfs(n: int, s: int, path: List[int]) -> None:\n      if n <= 1:\n        if len(path) > 1:\n          ans.append(path.copy())\n        return\n\n      for i in range(s, n + 1):\n        if n % i == 0:\n          path.append(i)\n          dfs(n // i, i, path)\n          path.pop()\n\n    dfs(n, 2, [])  # The smallest factor is 2\n    return ans\n"
    }
  ],
  [
    {
      "id": "255. Verify Preorder Sequence in Binary Search Tree",
      "code": "class Solution:\n  def verifyPreorder(self, preorder: List[int]) -> bool:\n    i = 0\n\n    def dfs(min: int, max: int) -> None:\n      nonlocal i\n      if i == len(preorder):\n        return\n      if preorder[i] < min or preorder[i] > max:\n        return\n\n      val = preorder[i]\n      i += 1\n      dfs(min, val)\n      dfs(val, max)\n\n    dfs(-math.inf, math.inf)\n    return i == len(preorder)\n"
    }
  ],
  [
    {
      "id": "256. Paint House",
      "code": "class Solution:\n  def minCost(self, costs: List[List[int]]) -> List[List[int]]:\n    for i in range(1, len(costs)):\n      costs[i][0] += min(costs[i - 1][1], costs[i - 1][2])\n      costs[i][1] += min(costs[i - 1][0], costs[i - 1][2])\n      costs[i][2] += min(costs[i - 1][0], costs[i - 1][1])\n\n    return min(costs[-1])\n"
    }
  ],
  [
    {
      "id": "257. Binary Tree Paths",
      "code": "class Solution:\n  def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\n    ans = []\n\n    def dfs(root: Optional[TreeNode], path: List[str]) -> None:\n      if not root:\n        return\n      if not root.left and not root.right:\n        ans.append(''.join(path) + str(root.val))\n        return\n\n      path.append(str(root.val) + '->')\n      dfs(root.left, path)\n      dfs(root.right, path)\n      path.pop()\n\n    dfs(root, [])\n    return ans\n"
    }
  ],
  [
    {
      "id": "258. Add Digits",
      "code": "class Solution:\n  def addDigits(self, num: int) -> int:\n    return 0 if num == 0 else 1 + (num - 1) % 9\n"
    }
  ],
  [
    {
      "id": "259. 3Sum Smaller",
      "code": "class Solution:\n  def threeSumSmaller(self, nums: List[int], target: int) -> int:\n    if len(nums) < 3:\n      return 0\n\n    ans = 0\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n      l = i + 1\n      r = len(nums) - 1\n      while l < r:\n        if nums[i] + nums[l] + nums[r] < target:\n          # (nums[i], nums[l], nums[r])\n          # (nums[i], nums[l], nums[r - 1])\n          # ...,\n          # (nums[i], nums[l], nums[l + 1])\n          ans += r - l\n          l += 1\n        else:\n          r -= 1\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "260. Single Number III",
      "code": "class Solution:\n  def singleNumber(self, nums: List[int]) -> List[int]:\n    xors = functools.reduce(operator.xor, nums)\n    lowbit = xors & -xors\n    ans = [0, 0]\n\n    # Seperate nums into two groups by the lowbit\n    for num in nums:\n      if num & lowbit:\n        ans[0] ^= num\n      else:\n        ans[1] ^= num\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "261. Graph Valid Tree",
      "code": "class Solution:\n  def validTree(self, n: int, edges: List[List[int]]) -> bool:\n    if n == 0 or len(edges) != n - 1:\n      return False\n\n    graph = [[] for _ in range(n)]\n    q = collections.deque([0])\n    seen = {0}\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        if v not in seen:\n          q.append(v)\n          seen.add(v)\n\n    return len(seen) == n\n"
    }
  ],
  null,
  [
    {
      "id": "263. Ugly Number",
      "code": "class Solution:\n  def isUgly(self, n: int) -> bool:\n    if n == 0:\n      return False\n\n    for prime in 2, 3, 5:\n      while n % prime == 0:\n        n //= prime\n\n    return n == 1\n"
    }
  ],
  [
    {
      "id": "264. Ugly Number II",
      "code": "class Solution:\n  def nthUglyNumber(self, n: int) -> int:\n    nums = [1]\n    i2 = 0\n    i3 = 0\n    i5 = 0\n\n    while len(nums) < n:\n      next2 = nums[i2] * 2\n      next3 = nums[i3] * 3\n      next5 = nums[i5] * 5\n      next = min(next2, next3, next5)\n      if next == next2:\n        i2 += 1\n      if next == next3:\n        i3 += 1\n      if next == next5:\n        i5 += 1\n      nums.append(next)\n\n    return nums[-1]\n"
    }
  ],
  [
    {
      "id": "265. Paint House II",
      "code": "class Solution:\n  def minCostII(self, costs: List[List[int]]) -> int:\n    prevIndex = -1  # The previous minimum index\n    prevMin1 = 0    # Minimum cost so far\n    prevMin2 = 0    # 2nd minimum cost so far\n\n    for cost in costs:   # O(n)\n      index = -1  # The painted index s.t. achieve the minimum cost after painting current house\n      min1 = math.inf  # The minimum cost after painting current house\n      min2 = math.inf  # The 2nd minimum cost after painting current house\n      for i, cst in enumerate(cost):   # O(k)\n        theCost = cst + (prevMin2 if i == prevIndex else prevMin1)\n        if theCost < min1:\n          index = i\n          min2 = min1\n          min1 = theCost\n        elif theCost < min2:   # Min1 <= theCost < min2\n          min2 = theCost\n\n      prevIndex = index\n      prevMin1 = min1\n      prevMin2 = min2\n\n    return prevMin1\n"
    }
  ],
  [
    {
      "id": "266. Palindrome Permutation",
      "code": "class Solution:\n  def canPermutePalindrome(self, s: str) -> bool:\n    seen = set()\n\n    for c in s:\n      if c in seen:\n        seen.remove(c)\n      else:\n        seen.add(c)\n\n    return len(seen) <= 1\n"
    }
  ],
  [
    {
      "id": "267. Palindrome Permutation II",
      "code": "class Solution:\n  def generatePalindromes(self, s: str) -> List[str]:\n    # Get character occurrence\n    count = collections.Counter(s)\n\n    # Count odd one\n    odd = sum(value & 1 for value in count.values())\n\n    # can't form any palindrome\n    if odd > 1:\n      return []\n\n    ans = []\n    candidates = []\n    mid = ''\n\n    # Get mid and candidates characters\n    for key, value in count.items():\n      if value & 1:\n        mid += key\n      for _ in range(value // 2):\n        candidates.append(key)\n\n    # Generate all unique palindromes from candidates\n    def dfs(used: List[bool], path: List[chr]) -> None:\n      if len(path) == len(candidates):\n        ans.append(''.join(path) + mid + ''.join(path[::-1]))\n        return\n\n      for i, candidate in enumerate(candidates):\n        if used[i]:\n          continue\n        if i > 0 and candidate == candidates[i - 1] and not used[i - 1]:\n          continue\n        used[i] = True\n        path.append(candidate)\n        dfs(used, path)\n        path.pop()\n        used[i] = False\n\n    # Backtracking to generate our ans (strings)\n    dfs([False] * len(candidates), [])\n    return ans\n"
    }
  ],
  [
    {
      "id": "268. Missing Number",
      "code": "class Solution:\n  def missingNumber(self, nums: List[int]) -> int:\n    ans = len(nums)\n\n    for i, num in enumerate(nums):\n      ans ^= i ^ num\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "269. Alien Dictionary",
      "code": "class Solution:\n  def alienOrder(self, words: List[str]) -> str:\n    graph = {}\n    inDegree = [0] * 26\n\n    self._buildGraph(graph, words, inDegree)\n    return self._topology(graph, inDegree)\n\n  def _buildGraph(self, graph: Dict[chr, Set[chr]], words: List[str], inDegree: List[int]) -> None:\n    # Create node for each character in each word\n    for word in words:\n      for c in word:\n        if c not in graph:\n          graph[c] = set()\n\n    for first, second in zip(words, words[1:]):\n      length = min(len(first), len(second))\n      for j in range(length):\n        u = first[j]\n        v = second[j]\n        if u != v:\n          if v not in graph[u]:\n            graph[u].add(v)\n            inDegree[ord(v) - ord('a')] += 1\n          break  # Later characters' order are meaningless\n        # First = 'ab', second = 'a' . invalid\n        if j == length - 1 and len(first) > len(second):\n          graph.clear()\n          return\n\n  def _topology(self, graph: Dict[chr, Set[chr]], inDegree: List[int]) -> str:\n    s = ''\n    q = collections.deque()\n\n    for c in graph:\n      if inDegree[ord(c) - ord('a')] == 0:\n        q.append(c)\n\n    while q:\n      u = q.pop()\n      s += u\n      for v in graph[u]:\n        inDegree[ord(v) - ord('a')] -= 1\n        if inDegree[ord(v) - ord('a')] == 0:\n          q.append(v)\n\n    # Words = ['z', 'x', 'y', 'x']\n    return s if len(s) == len(graph) else ''\n"
    }
  ],
  [
    {
      "id": "270. Closest Binary Search Tree Value",
      "code": "class Solution:\n  def closestValue(self, root: Optional[TreeNode], target: float) -> int:\n    # If target < root.val, search left subtree\n    if target < root.val and root.left:\n      left = self.closestValue(root.left, target)\n      if abs(left - target) < abs(root.val - target):\n        return left\n\n    # If target > root.val, search right subtree\n    if target > root.val and root.right:\n      right = self.closestValue(root.right, target)\n      if abs(right - target) < abs(root.val - target):\n        return right\n\n    return root.val\n"
    }
  ],
  [
    {
      "id": "271. Encode and Decode Strings",
      "code": "class Codec:\n  def encode(self, strs: List[str]) -> str:\n    \"\"\"Encodes a list of strings to a single string.\"\"\"\n    return ''.join(str(len(s)) + '/' + s for s in strs)\n\n  def decode(self, s: str) -> List[str]:\n    \"\"\"Decodes a single to a list of strings.\"\"\"\n    decoded = []\n\n    i = 0\n    while i < len(s):\n      slash = s.find('/', i)\n      length = int(s[i:slash])\n      i = slash + length + 1\n      decoded.append(s[slash + 1:i])\n\n    return decoded\n"
    }
  ],
  [
    {
      "id": "272. Closest Binary Search Tree Value II",
      "code": "class Solution:\n  def closestKValues(self, root: Optional[TreeNode], target: float, k: int) -> List[int]:\n    q = collections.deque()\n\n    def inorder(root: Optional[TreeNode]) -> None:\n      if not root:\n        return\n\n      inorder(root.left)\n      q.append(root.val)\n      inorder(root.right)\n\n    inorder(root)\n\n    while len(q) > k:\n      if abs(q[0] - target) > abs(q[-1] - target):\n        q.popleft()\n      else:\n        q.pop()\n\n    return list(q)\n"
    }
  ],
  [
    {
      "id": "273. Integer to English Words",
      "code": "class Solution:\n  def numberToWords(self, num: int) -> str:\n    if num == 0:\n      return \"Zero\"\n\n    belowTwenty = [\"\",        \"One\",       \"Two\",      \"Three\",\n                   \"Four\",    \"Five\",      \"Six\",      \"Seven\",\n                   \"Eight\",   \"Nine\",      \"Ten\",      \"Eleven\",\n                   \"Twelve\",  \"Thirteen\",  \"Fourteen\", \"Fifteen\",\n                   \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n    tens = [\"\",      \"Ten\",   \"Twenty\",  \"Thirty\", \"Forty\",\n            \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n\n    def helper(num: int) -> str:\n      if num < 20:\n        s = belowTwenty[num]\n      elif num < 100:\n        s = tens[num // 10] + \" \" + belowTwenty[num % 10]\n      elif num < 1000:\n        s = helper(num // 100) + \" Hundred \" + helper(num % 100)\n      elif num < 1000000:\n        s = helper(num // 1000) + \" Thousand \" + helper(num % 1000)\n      elif num < 1000000000:\n        s = helper(num // 1000000) + \" Million \" + \\\n            helper(num % 1000000)\n      else:\n        s = helper(num // 1000000000) + \" Billion \" + \\\n            helper(num % 1000000000)\n\n      return s.strip()\n\n    return helper(num)\n"
    }
  ],
  [
    {
      "id": "274. H-Index",
      "code": "class Solution:\n  def hIndex(self, citations: List[int]) -> int:\n    n = len(citations)\n    accumulate = 0\n    count = [0] * (n + 1)\n\n    for citation in citations:\n      count[min(citation, n)] += 1\n\n    # To find the largeset h-index, loop from back to front\n    # I is the candidate h-index\n    for i, c in reversed(list(enumerate(count))):\n      accumulate += c\n      if accumulate >= i:\n        return i\n"
    }
  ],
  [
    {
      "id": "275. H-Index II",
      "code": "class Solution:\n  def hIndex(self, citations: List[int]) -> int:\n    l = 0\n    r = len(citations)\n\n    while l < r:\n      m = (l + r) // 2\n      if citations[m] >= len(citations) - m:\n        r = m\n      else:\n        l = m + 1\n\n    return len(citations) - l\n"
    }
  ],
  [
    {
      "id": "276. Paint Fence",
      "code": "class Solution:\n  def numWays(self, n: int, k: int) -> int:\n    if n == 0:\n      return 0\n    if n == 1:\n      return k\n    if n == 2:\n      return k * k\n\n    # dp[i] := # Of ways to pan posts with k colors\n    dp = [0] * (n + 1)\n    dp[0] = 0\n    dp[1] = k\n    dp[2] = k * k\n\n    for i in range(3, n + 1):\n      dp[i] = (dp[i - 1] + dp[i - 2]) * (k - 1)\n\n    return dp[n]\n"
    }
  ],
  null,
  [
    {
      "id": "278. First Bad Version",
      "code": "class Solution:\n  def firstBadVersion(self, n: int) -> int:\n    l = 1\n    r = n\n\n    while l < r:\n      m = (l + r) >> 1\n      if isBadVersion(m):\n        r = m\n      else:\n        l = m + 1\n\n    return l\n"
    }
  ],
  [
    {
      "id": "279. Perfect Squares",
      "code": "class Solution:\n  def numSquares(self, n: int) -> int:\n    dp = [n] * (n + 1)\n\n    dp[0] = 0\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n      j = 1\n      while j * j <= i:\n        dp[i] = min(dp[i], dp[i - j * j] + 1)\n        j += 1\n\n    return dp[n]\n"
    }
  ],
  [
    {
      "id": "280. Wiggle Sort",
      "code": "class Solution:\n  def wiggleSort(self, nums: List[int]) -> None:\n    # 1. if i is even, then nums[i] <= nums[i - 1]\n    # 2. if i is odd, then nums[i] >= nums[i - 1]\n    for i in range(1, len(nums)):\n      if not (i & 1) and nums[i] > nums[i - 1] or (i & 1) and nums[i] < nums[i - 1]:\n        nums[i], nums[i - 1] = nums[i - 1], nums[i]\n"
    }
  ],
  [
    {
      "id": "281. Zigzag Iterator",
      "code": "class ZigzagIterator:\n  def __init__(self, v1: List[int], v2: List[int]):\n    def vals():\n      for i in itertools.count():\n        for v in v1, v2:\n          if i < len(v):\n            yield v[i]\n    self.vals = vals()\n    self.n = len(v1) + len(v2)\n\n  def next(self):\n    self.n -= 1\n    return next(self.vals)\n\n  def hasNext(self):\n    return self.n > 0\n"
    }
  ],
  [
    {
      "id": "282. Expression Add Operators",
      "code": "class Solution:\n  def addOperators(self, num: str, target: int) -> List[str]:\n    ans = []\n\n    # Start index, prev value, current evaluated value\n    def dfs(start: int, prev: int, eval: int, path: List[str]) -> None:\n      if start == len(num):\n        if eval == target:\n          ans.append(''.join(path))\n        return\n\n      for i in range(start, len(num)):\n        if i > start and num[start] == '0':\n          return\n        s = num[start:i + 1]\n        curr = int(s)\n        if start == 0:\n          path.append(s)\n          dfs(i + 1, curr, curr, path)\n          path.pop()\n        else:\n          for op in ['+', '-', '*']:\n            path.append(op + s)\n            if op == '+':\n              dfs(i + 1, curr, eval + curr, path)\n            elif op == '-':\n              dfs(i + 1, -curr, eval - curr, path)\n            else:\n              dfs(i + 1, prev * curr, eval - prev + prev * curr, path)\n            path.pop()\n\n    dfs(0, 0, 0, [])\n    return ans\n"
    }
  ],
  [
    {
      "id": "283. Move Zeroes",
      "code": "class Solution:\n  def moveZeroes(self, nums: List[int]) -> None:\n    j = 0\n    for num in nums:\n      if num != 0:\n        nums[j] = num\n        j += 1\n\n    for i in range(j, len(nums)):\n      nums[i] = 0\n"
    }
  ],
  [
    {
      "id": "284. Peeking Iterator",
      "code": "class PeekingIterator:\n  def __init__(self, iterator: Iterator):\n    self.iterator = iterator\n    self.buffer = self.iterator.next() if self.iterator.hasNext() else None\n\n  def peek(self) -> int:\n    \"\"\"\n    Returns the next element in the iteration without advancing the iterator.\n    \"\"\"\n    return self.buffer\n\n  def next(self) -> int:\n    next = self.buffer\n    self.buffer = self.iterator.next() if self.iterator.hasNext() else None\n    return next\n\n  def hasNext(self) -> bool:\n    return self.buffer is not None\n"
    }
  ],
  [
    {
      "id": "285. Inorder Successor in BST",
      "code": "class Solution:\n  def inorderSuccessor(self, root: Optional[TreeNode], p: Optional[TreeNode]) -> Optional[TreeNode]:\n    if not root:\n      return None\n    if root.val <= p.val:\n      return self.inorderSuccessor(root.right, p)\n    return self.inorderSuccessor(root.left, p) or root\n"
    }
  ],
  [
    {
      "id": "286. Walls and Gates",
      "code": "class Solution:\n  def wallsAndGates(self, rooms: List[List[int]]) -> None:\n    kInf = 2**31 - 1\n    m = len(rooms)\n    n = len(rooms[0])\n    dirs = [0, 1, 0, -1, 0]\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if rooms[i][j] == 0:\n          q.append((i, j))\n\n    while q:\n      i, j = q.popleft()\n      for k in range(4):\n        x = i + dirs[k]\n        y = j + dirs[k + 1]\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if rooms[x][y] != kInf:\n          continue\n        rooms[x][y] = rooms[i][j] + 1\n        q.append((x, y))\n"
    }
  ],
  [
    {
      "id": "287. Find the Duplicate Number",
      "code": "class Solution:\n  def findDuplicate(self, nums: List[int]) -> int:\n    slow = nums[nums[0]]\n    fast = nums[nums[nums[0]]]\n\n    while slow != fast:\n      slow = nums[slow]\n      fast = nums[nums[fast]]\n\n    slow = nums[0]\n\n    while slow != fast:\n      slow = nums[slow]\n      fast = nums[fast]\n\n    return slow\n"
    }
  ],
  [
    {
      "id": "288. Unique Word Abbreviation",
      "code": "class ValidWordAbbr:\n  def __init__(self, dictionary: List[str]):\n    self.dict = set(dictionary)\n    # T := unique, F := not unique\n    self.abbrUnique = {}\n\n    for word in self.dict:\n      abbr = self._getAbbr(word)\n      self.abbrUnique[abbr] = abbr not in self.abbrUnique\n\n  def isUnique(self, word: str) -> bool:\n    abbr = self._getAbbr(word)\n    return abbr not in self.abbrUnique or self.abbrUnique[abbr] and word in self.dict\n\n  def _getAbbr(self, s: str) -> str:\n    n = len(s)\n    if n <= 2:\n      return s\n    return s[0] + str(n - 2) + s[-1]\n"
    }
  ],
  [
    {
      "id": "289. Game of Life",
      "code": "class Solution:\n  def gameOfLife(self, board: List[List[int]]) -> None:\n    m = len(board)\n    n = len(board[0])\n\n    for i in range(m):\n      for j in range(n):\n        ones = 0\n        for x in range(max(0, i - 1), min(m, i + 2)):\n          for y in range(max(0, j - 1), min(n, j + 2)):\n            ones += board[x][y] & 1\n        # Any live cell with 2 or 3 live neighbors\n        # lives on to the next generation\n        if board[i][j] == 1 and (ones == 3 or ones == 4):\n          board[i][j] |= 0b10\n        # Any dead cell with exactly 3 live neighbors\n        # becomes a live cell, as if by reproduction\n        if board[i][j] == 0 and ones == 3:\n          board[i][j] |= 0b10\n\n    for i in range(m):\n      for j in range(n):\n        board[i][j] >>= 1\n"
    }
  ],
  [
    {
      "id": "290. Word Pattern",
      "code": "class Solution:\n  def wordPattern(self, pattern: str, str: str) -> bool:\n    t = str.split()\n    return [*map(pattern.index, pattern)] == [*map(t.index, t)]\n"
    }
  ],
  [
    {
      "id": "291. Word Pattern II",
      "code": "class Solution:\n  def wordPatternMatch(self, pattern: str, s: str) -> bool:\n    def isMatch(i: int, j: int, charToString: Dict[chr, str], seen: Set[str]) -> bool:\n      if i == len(pattern) and j == len(s):\n        return True\n      if i == len(pattern) or j == len(s):\n        return False\n\n      c = pattern[i]\n\n      if c in charToString:\n        t = charToString[c]\n        # Check if we can match t w// s[j..j + len(t))\n        if t not in s[j:]:\n          return False\n\n        # If can match, so continue match the rest\n        return isMatch(i + 1, j + len(t), charToString, seen)\n\n      for k in range(j, len(s)):\n        t = s[j:k + 1]\n\n        # This is already mapped by other character\n        if t in seen:\n          continue\n\n        charToString[c] = t\n        seen.add(t)\n\n        if isMatch(i + 1, k + 1, charToString, seen):\n          return True\n\n        # Backtracking\n        del charToString[c]\n        seen.remove(t)\n\n      return False\n\n    return isMatch(0, 0, {}, set())\n"
    }
  ],
  [
    {
      "id": "292. Nim Game",
      "code": "class Solution:\n  def canWinNim(self, n: int) -> bool:\n    return n % 4 != 0\n"
    }
  ],
  [
    {
      "id": "293. Flip Game",
      "code": "class Solution:\n  def generatePossibleNextMoves(self, currentState: str) -> List[str]:\n    return [currentState[:i] + '--' + currentState[i + 2:]\n            for i, (a, b) in enumerate(zip(currentState, currentState[1:]))\n            if a == '+' and b == '+']\n"
    }
  ],
  [
    {
      "id": "294. Flip Game II",
      "code": "class Solution:\n  @functools.lru_cache(None)\n  def canWin(self, currentState: str) -> bool:\n    # If any of currentState[i:i + 2] == \"++\" and your friend can't win after\n    # Changing currentState[i:i + 2] to \"--\" (or \"-\"), then you can win\n    return any(True\n               for i, (a, b) in enumerate(zip(currentState, currentState[1:]))\n               if a == '+' and b == '+' and\n               not self.canWin(currentState[:i] + '-' + currentState[i + 2:]))\n"
    }
  ],
  [
    {
      "id": "295. Find Median from Data Stream",
      "code": "class MedianFinder:\n  def __init__(self):\n    self.maxHeap = []\n    self.minHeap = []\n\n  def addNum(self, num: int) -> None:\n    if not self.maxHeap or num <= -self.maxHeap[0]:\n      heapq.heappush(self.maxHeap, -num)\n    else:\n      heapq.heappush(self.minHeap, num)\n\n    # Balance two heaps s.t.\n    # |maxHeap| >= |minHeap| and |maxHeap| - |minHeap| <= 1\n    if len(self.maxHeap) < len(self.minHeap):\n      heapq.heappush(self.maxHeap, -heapq.heappop(self.minHeap))\n    elif len(self.maxHeap) - len(self.minHeap) > 1:\n      heapq.heappush(self.minHeap, -heapq.heappop(self.maxHeap))\n\n  def findMedian(self) -> float:\n    if len(self.maxHeap) == len(self.minHeap):\n      return (-self.maxHeap[0] + self.minHeap[0]) / 2.0\n    return -self.maxHeap[0]\n"
    }
  ],
  [
    {
      "id": "296. Best Meeting Point",
      "code": "class Solution:\n  def minTotalDistance(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # I indices s.t. grid[i][j] == 1\n    I = [i for i in range(m) for j in range(n) if grid[i][j]]\n    # J indices s.t. grid[i][j] == 1\n    J = [j for j in range(n) for i in range(m) if grid[i][j]]\n\n    def minTotalDistance(grid: List[int]) -> int:\n      summ = 0\n      i = 0\n      j = len(grid) - 1\n\n      while i < j:\n        summ += grid[j] - grid[i]\n        i += 1\n        j -= 1\n\n      return summ\n\n    # Sum(i - median(I)) + sum(j - median(J))\n    return minTotalDistance(I) + minTotalDistance(J)\n"
    }
  ],
  [
    {
      "id": "297. Serialize and Deserialize Binary Tree",
      "code": "class Codec:\n  def serialize(self, root: 'TreeNode') -> str:\n    \"\"\"Encodes a tree to a single string.\"\"\"\n    if not root:\n      return ''\n\n    s = ''\n    q = collections.deque([root])\n\n    while q:\n      node = q.popleft()\n      if node:\n        s += str(node.val) + ' '\n        q.append(node.left)\n        q.append(node.right)\n      else:\n        s += 'n '\n\n    return s\n\n  def deserialize(self, data: str) -> 'TreeNode':\n    \"\"\"Decodes your encoded data to tree.\"\"\"\n    if not data:\n      return None\n\n    vals = data.split()\n    root = TreeNode(vals[0])\n    q = collections.deque([root])\n\n    for i in range(1, len(vals), 2):\n      node = q.popleft()\n      if vals[i] != 'n':\n        node.left = TreeNode(vals[i])\n        q.append(node.left)\n      if vals[i + 1] != 'n':\n        node.right = TreeNode(vals[i + 1])\n        q.append(node.right)\n\n    return root\n"
    }
  ],
  [
    {
      "id": "298. Binary Tree Longest Consecutive Sequence",
      "code": "class Solution:\n  def longestConsecutive(self, root: Optional[TreeNode]) -> int:\n    if not root:\n      return 0\n\n    def dfs(root: Optional[TreeNode], target: int, length: int, maxLength: int) -> int:\n      if not root:\n        return maxLength\n      if root.val == target:\n        length += 1\n        maxLength = max(maxLength, length)\n      else:\n        length = 1\n      return max(dfs(root.left, root.val + 1, length, maxLength),\n                 dfs(root.right, root.val + 1, length, maxLength))\n\n    return dfs(root, root.val, 0, 0)\n"
    }
  ],
  [
    {
      "id": "299. Bulls and Cows",
      "code": "class Solution:\n  def getHint(self, secret: str, guess: str) -> str:\n    bulls = sum(map(operator.eq, secret, guess))\n    bovine = sum(min(secret.count(x), guess.count(x)) for x in set(guess))\n    return '%dA%dB' % (bulls, bovine - bulls)\n"
    }
  ],
  [
    {
      "id": "300. Longest Increasing Subsequence",
      "code": "class Solution:\n  def lengthOfLIS(self, nums: List[int]) -> int:\n    if not nums:\n      return 0\n\n    # dp[i] := LIS ending at nums[i]\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n      for j in range(i):\n        if nums[j] < nums[i]:\n          dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n"
    }
  ],
  [
    {
      "id": "301. Remove Invalid Parentheses",
      "code": "class Solution:\n  def removeInvalidParentheses(self, s: str) -> List[str]:\n    def getLeftAndRightCounts(s: str) -> tuple:\n      l = 0\n      r = 0\n\n      for c in s:\n        if c == '(':\n          l += 1\n        elif c == ')':\n          if l == 0:\n            r += 1\n          else:\n            l -= 1\n\n      return l, r\n\n    def isValid(s: str):\n      count = 0  # Number of '(' - # Of ')'\n      for c in s:\n        if c == '(':\n          count += 1\n        elif c == ')':\n          count -= 1\n        if count < 0:\n          return False\n      return True  # Count == 0\n\n    ans = []\n\n    def dfs(s: str, start: int, l: int, r: int) -> None:\n      if l == 0 and r == 0 and isValid(s):\n        ans.append(s)\n        return\n\n      for i in range(start, len(s)):\n        if i > start and s[i] == s[i - 1]:\n          continue\n        if r > 0 and s[i] == ')':  # Delete s[i]\n          dfs(s[:i] + s[i + 1:], i, l, r - 1)\n        elif l > 0 and s[i] == '(':  # Delete s[i]\n          dfs(s[:i] + s[i + 1:], i, l - 1, r)\n\n    l, r = getLeftAndRightCounts(s)\n    dfs(s, 0, l, r)\n    return ans\n"
    }
  ],
  [
    {
      "id": "302. Smallest Rectangle Enclosing Black Pixels",
      "code": "class Solution:\n  def minArea(self, image: List[List[str]], x: int, y: int) -> int:\n    m = len(image)\n    n = len(image[0])\n    dirs = [0, 1, 0, -1, 0]\n    topLeft = [x, y]\n    bottomRight = [x, y]\n    q = collections.deque([(x, y)])\n    image[x][y] = '2'  # Visited\n\n    while q:\n      i, j = q.popleft()\n      for k in range(4):\n        r = i + dirs[k]\n        c = j + dirs[k + 1]\n        if r < 0 or r == m or c < 0 or c == n:\n          continue\n        if image[r][c] != '1':\n          continue\n        topLeft[0] = min(topLeft[0], r)\n        topLeft[1] = min(topLeft[1], c)\n        bottomRight[0] = max(bottomRight[0], r)\n        bottomRight[1] = max(bottomRight[1], c)\n        q.append((r, c))\n        image[r][c] = '2'\n\n    width = bottomRight[1] - topLeft[1] + 1\n    height = bottomRight[0] - topLeft[0] + 1\n    return width * height\n"
    }
  ],
  [
    {
      "id": "303. Range Sum Query - Immutable",
      "code": "class NumArray:\n  def __init__(self, nums: List[int]):\n    self.prefix = [0] + list(itertools.accumulate(nums))\n\n  def sumRange(self, left: int, right: int) -> int:\n    return self.prefix[right + 1] - self.prefix[left]\n"
    }
  ],
  [
    {
      "id": "304. Range Sum Query 2D - Immutable",
      "code": "class NumMatrix:\n  def __init__(self, matrix: List[List[int]]):\n    if not matrix:\n      return\n\n    m = len(matrix)\n    n = len(matrix[0])\n    # prefix[i][j] := sum of matrix[0..i)[0..j)\n    self.prefix = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n      for j in range(n):\n        self.prefix[i + 1][j + 1] = \\\n            matrix[i][j] + self.prefix[i][j + 1] + \\\n            self.prefix[i + 1][j] - self.prefix[i][j]\n\n  def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:\n    return self.prefix[row2 + 1][col2 + 1] - self.prefix[row1][col2 + 1] - \\\n        self.prefix[row2 + 1][col1] + self.prefix[row1][col1]\n"
    }
  ],
  [
    {
      "id": "305. Number of Islands II",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = [-1] * n\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = self.id[j]\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = self.id[i]\n    else:\n      self.id[i] = self.id[j]\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\n class Solution:\n  def numIslands2(self, m: int, n: int, positions: List[List[int]]) -> List[int]:\n    dirs = [0, 1, 0, -1, 0]\n    ans = []\n    seen = [[False] * n for _ in range(m)]\n    uf = UnionFind(m * n)\n    count = 0\n\n    def getId(i: int, j: int, n: int) -> int:\n      return i * n + j\n\n    for i, j in positions:\n      if seen[i][j]:\n        ans.append(count)\n        continue\n      seen[i][j] = True\n      id = getId(i, j, n)\n      uf.id[id] = id\n      count += 1\n      for k in range(4):\n        x = i + dirs[k]\n        y = j + dirs[k + 1]\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        neighborId = getId(x, y, n)\n        if uf.id[neighborId] == -1:  # Water\n          continue\n        currentParent = uf.find(id)\n        neighborParent = uf.find(neighborId)\n        if currentParent != neighborParent:\n          uf.unionByRank(currentParent, neighborParent)\n          count -= 1\n      ans.append(count)\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "306. Additive Number",
      "code": "class Solution:\n  def isAdditiveNumber(self, num: str) -> bool:\n    n = len(num)\n\n    def dfs(firstNum: int, secondNum: int, s: int) -> bool:\n      if s == len(num):\n        return True\n\n      thirdNum = firstNum + secondNum\n      thirdNumStr = str(thirdNum)\n\n      return num.find(thirdNumStr, s) == s and dfs(secondNum, thirdNum, s + len(thirdNumStr))\n\n    # num[0..i] = firstNum\n    for i in range(n // 2):\n      if i > 0 and num[0] == '0':\n        return False\n      firstNum = int(num[:i + 1])\n      # num[i + 1..j] = secondNum\n      # Len(thirdNum) >= max(len(firstNum), len(secondNum))\n      j = i + 1\n      while max(i, j - i) < n - j:\n        if j > i + 1 and num[i + 1] == '0':\n          break\n        secondNum = int(num[i + 1:j + 1])\n        if dfs(firstNum, secondNum, j + 1):\n          return True\n        j += 1\n\n    return False\n"
    }
  ],
  [
    {
      "id": "307. Range Sum Query - Mutable",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def update(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\n class NumArray:\n  def __init__(self, nums: List[int]):\n    self.nums = nums\n    self.tree = FenwickTree(len(nums))\n    for i, num in enumerate(nums):\n      self.tree.update(i + 1, num)\n\n  def update(self, index: int, val: int) -> None:\n    self.tree.update(index + 1, val - self.nums[index])\n    self.nums[index] = val\n\n  def sumRange(self, left: int, right: int) -> int:\n    return self.tree.get(right + 1) - self.tree.get(left)\n"
    }
  ],
  [
    {
      "id": "308. Range Sum Query 2D - Mutable",
      "code": "class FenwickTree:\n  def __init__(self, m: int, n: int):\n    self.sums = [[0] * (n + 1) for _ in range(m + 1)]\n\n  def update(self, row: int, col: int, delta: int) -> None:\n    i = row\n    while i < len(self.sums):\n      j = col\n      while j < len(self.sums[0]):\n        self.sums[i][j] += delta\n        j += j & -j\n      i += FenwickTree.lowbit(i)\n\n  def get(self, row: int, col: int) -> int:\n    summ = 0\n    i = row\n    while i > 0:\n      j = col\n      while j > 0:\n        summ += self.sums[i][j]\n        j -= j & -j\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\n class NumMatrix:\n  def __init__(self, matrix: List[List[int]]):\n    self.matrix = matrix\n    self.tree = FenwickTree(len(matrix), len(matrix[0]))\n\n    for i in range(len(matrix)):\n      for j, val in enumerate(matrix[i]):\n        self.tree.update(i + 1, j + 1, val)\n\n  def update(self, row: int, col: int, val: int) -> None:\n    self.tree.update(row + 1, col + 1, val - self.matrix[row][col])\n    self.matrix[row][col] = val\n\n  def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:\n    return self.tree.get(row2 + 1, col2 + 1) - self.tree.get(row1, col2 + 1) - \\\n        self.tree.get(row2 + 1, col1) + self.tree.get(row1, col1)\n"
    }
  ],
  [
    {
      "id": "309. Best Time to Buy and Sell Stock with Cooldown",
      "code": "class Solution:\n  def maxProfit(self, prices: List[int]) -> int:\n    sell = 0\n    hold = -math.inf\n    prev = 0\n\n    for price in prices:\n      cache = sell\n      sell = max(sell, hold + price)\n      hold = max(hold, prev - price)\n      prev = cache\n\n    return sell\n"
    }
  ],
  [
    {
      "id": "310. Minimum Height Trees",
      "code": "class Solution:\n  def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\n    if n == 1 or not edges:\n      return [0]\n\n    ans = []\n    graph = collections.defaultdict(set)\n\n    for u, v in edges:\n      graph[u].add(v)\n      graph[v].add(u)\n\n    for label, children in graph.items():\n      if len(children) == 1:\n        ans.append(label)\n\n    while n > 2:\n      n -= len(ans)\n      nextLeaves = []\n      for leaf in ans:\n        u = next(iter(graph[leaf]))\n        graph[u].remove(leaf)\n        if len(graph[u]) == 1:\n          nextLeaves.append(u)\n      ans = nextLeaves\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "311. Sparse Matrix Multiplication",
      "code": "class Solution:\n  def multiply(self, mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]:\n    m = len(mat1)\n    n = len(mat2)\n    l = len(mat2[0])\n    ans = [[0] * l for _ in range(m)]\n\n    for i in range(m):\n      for j in range(l):\n        for k in range(n):\n          ans[i][j] += mat1[i][k] * mat2[k][j]\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "312. Burst Balloons",
      "code": "class Solution:\n  def maxCoins(self, nums: List[int]) -> int:\n    A = [1] + nums + [1]\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int) -> int:\n      if i > j:\n        return 0\n\n      return max(dp(i, k - 1) + dp(k + 1, j) + A[i - 1] * A[k] * A[j + 1]\n                 for k in range(i, j + 1))\n\n    return dp(1, len(nums))\n"
    }
  ],
  [
    {
      "id": "313. Super Ugly Number",
      "code": "class Solution:\n  def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\n    k = len(primes)\n    nums = [1]\n    indices = [0] * k\n\n    while len(nums) < n:\n      nexts = [0] * k\n      for i in range(k):\n        nexts[i] = nums[indices[i]] * primes[i]\n      next = min(nexts)\n      for i in range(k):\n        if next == nexts[i]:\n          indices[i] += 1\n      nums.append(next)\n\n    return nums[-1]\n"
    }
  ],
  [
    {
      "id": "314. Binary Tree Vertical Order Traversal",
      "code": "class Solution:\n  def verticalOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n    if not root:\n      return []\n\n    range_ = [0] * 2\n\n    def getRange(root: Optional[TreeNode], x: int) -> None:\n      if not root:\n        return\n\n      range_[0] = min(range_[0], x)\n      range_[1] = max(range_[1], x)\n\n      getRange(root.left, x - 1)\n      getRange(root.right, x + 1)\n\n    getRange(root, 0)  # Get the leftmost and rightmost x index\n\n    ans = [[] for _ in range(range_[1] - range_[0] + 1)]\n    q = collections.deque([(root, -range_[0])])  # (TreeNode, x)\n\n    while q:\n      node, x = q.popleft()\n      ans[x].append(node.val)\n      if node.left:\n        q.append((node.left, x - 1))\n      if node.right:\n        q.append((node.right, x + 1))\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "315. Count of Smaller Numbers After Self",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def update(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\n class Solution:\n  def countSmaller(self, nums: List[int]) -> List[int]:\n    ans = []\n    ranks = collections.Counter()\n    self._getRanks(nums, ranks)\n    tree = FenwickTree(len(ranks))\n\n    for num in reversed(nums):\n      ans.append(tree.get(ranks[num] - 1))\n      tree.update(ranks[num], 1)\n\n    return ans[::-1]\n\n  def _getRanks(self, nums: List[int], ranks: Dict[int, int]) -> None:\n    rank = 0\n    for num in sorted(set(nums)):\n      rank += 1\n      ranks[num] = rank\n"
    }
  ],
  [
    {
      "id": "316. Remove Duplicate Letters",
      "code": "class Solution:\n  def removeDuplicateLetters(self, s: str) -> str:\n    ans = []\n    count = collections.Counter(s)\n    used = [False] * 26\n\n    for c in s:\n      count[c] -= 1\n      if used[ord(c) - ord('a')]:\n        continue\n      while ans and ans[-1] > c and count[ans[-1]] > 0:\n        used[ord(ans[-1]) - ord('a')] = False\n        ans.pop()\n      ans.append(c)\n      used[ord(ans[-1]) - ord('a')] = True\n\n    return ''.join(ans)\n"
    }
  ],
  [
    {
      "id": "317. Shortest Distance from All Buildings",
      "code": "class Solution:\n  def shortestDistance(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    dirs = [0, 1, 0, -1, 0]\n    nBuildings = sum(a == 1 for row in grid for a in row)\n    ans = math.inf\n    # dist[i][j] := total distance of grid[i][j] (0) to reach all buildings (1)\n    dist = [[0] * n for _ in range(m)]\n    # reachCount[i][j] := # Of buildings (1) grid[i][j] (0) can reach\n    reachCount = [[0] * n for _ in range(m)]\n\n    def bfs(row: int, col: int) -> bool:\n      q = collections.deque([(row, col)])\n      seen = {(row, col)}\n      depth = 0\n      seenBuildings = 1\n\n      while q:\n        depth += 1\n        for _ in range(len(q)):\n          i, j = q.popleft()\n          for k in range(4):\n            x = i + dirs[k]\n            y = j + dirs[k + 1]\n            if x < 0 or x == m or y < 0 or y == n:\n              continue\n            if (x, y) in seen:\n              continue\n            seen.add((x, y))\n            if not grid[x][y]:\n              dist[x][y] += depth\n              reachCount[x][y] += 1\n              q.append((x, y))\n            elif grid[x][y] == 1:\n              seenBuildings += 1\n\n      # True if all buildings (1) are connected\n      return seenBuildings == nBuildings\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:  # Bfs from this building\n          if not bfs(i, j):\n            return -1\n\n    for i in range(m):\n      for j in range(n):\n        if reachCount[i][j] == nBuildings:\n          ans = min(ans, dist[i][j])\n\n    return -1 if ans == math.inf else ans\n"
    }
  ],
  [
    {
      "id": "318. Maximum Product of Word Lengths",
      "code": "class Solution:\n  def maxProduct(self, words: List[str]) -> int:\n    ans = 0\n\n    def getMask(word: str) -> int:\n      mask = 0\n      for c in word:\n        mask |= 1 << ord(c) - ord('a')\n      return mask\n\n    masks = [getMask(word) for word in words]\n\n    for i in range(len(words)):\n      for j in range(i):\n        if not (masks[i] & masks[j]):\n          ans = max(ans, len(words[i]) * len(words[j]))\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "319. Bulb Switcher",
      "code": "class Solution:\n  def bulbSwitch(self, n: int) -> int:\n    return int(sqrt(n))\n"
    }
  ],
  [
    {
      "id": "320. Generalized Abbreviation",
      "code": "class Solution:\n  def generateAbbreviations(self, word: str) -> List[str]:\n    ans = []\n\n    def getCountString(count: int) -> str:\n      return str(count) if count > 0 else ''\n\n    def dfs(i: int, count: int, path: List[str]) -> None:\n      if i == len(word):\n        ans.append(''.join(path) + getCountString(count))\n        return\n\n      # Abbreviate word[i]\n      dfs(i + 1, count + 1, path)\n      # Keep word[i], so consume the count as a string\n      path.append(getCountString(count) + word[i])\n      dfs(i + 1, 0, path)  # Reset count to 0\n      path.pop()\n\n    dfs(0, 0, [])\n    return ans\n"
    }
  ],
  null,
  [
    {
      "id": "322. Coin Change",
      "code": "class Solution:\n  def coinChange(self, coins: List[int], amount: int) -> int:\n    # dp[i] := fewest # Of coins to make up i\n    dp = [0] + [amount + 1] * amount\n\n    for coin in coins:\n      for i in range(coin, amount + 1):\n        dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return -1 if dp[amount] == amount + 1 else dp[amount]\n"
    }
  ],
  [
    {
      "id": "323. Number of Connected Components in an Undirected Graph",
      "code": "class Solution:\n  def countComponents(self, n: int, edges: List[List[int]]) -> int:\n    ans = 0\n    graph = [[] for _ in range(n)]\n    seen = set()\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    def bfs(node: int, seen: Set[int]) -> None:\n      q = collections.deque([node])\n      seen.add(node)\n\n      while q:\n        u = q.pop()\n        for v in graph[u]:\n          if v not in seen:\n            q.append(v)\n            seen.add(v)\n\n    for i in range(n):\n      if i not in seen:\n        bfs(i, seen)\n        ans += 1\n\n    return ans\n"
    }
  ],
  null,
  [
    {
      "id": "325. Maximum Size Subarray Sum Equals k",
      "code": "class Solution:\n  def maxSubArrayLen(self, nums: List[int], k: int) -> int:\n    ans = 0\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i, num in enumerate(nums):\n      prefix += num\n      target = prefix - k\n      if target in prefixToIndex:\n        ans = max(ans, i - prefixToIndex[target])\n      if prefix not in prefixToIndex:\n        prefixToIndex[prefix] = i\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "326. Power of Three",
      "code": "class Solution:\n  def isPowerOfThree(self, n: int) -> bool:\n    return n > 0 and 3**19 % n == 0\n"
    }
  ],
  [
    {
      "id": "327. Count of Range Sum",
      "code": "class Solution:\n  def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:\n    n = len(nums)\n    self.ans = 0\n    prefix = [0] + list(itertools.accumulate(nums))\n\n    self._mergeSort(prefix, 0, n, lower, upper)\n    return self.ans\n\n  def _mergeSort(self, prefix: List[int], l: int, r: int, lower: int, upper: int) -> None:\n    if l >= r:\n      return\n\n    m = (l + r) // 2\n    self._mergeSort(prefix, l, m, lower, upper)\n    self._mergeSort(prefix, m + 1, r, lower, upper)\n    self._merge(prefix, l, m, r, lower, upper)\n\n  def _merge(self, prefix: List[int], l: int, m: int, r: int, lower: int, upper: int) -> None:\n    lo = m + 1  # 1st index s.t. prefix[lo] - prefix[i] >= lower\n    hi = m + 1  # 1st index s.t. prefix[hi] - prefix[i] > upper\n\n    # For each index i in range [l, m], add hi - lo to ans\n    for i in range(l, m + 1):\n      while lo <= r and prefix[lo] - prefix[i] < lower:\n        lo += 1\n      while hi <= r and prefix[hi] - prefix[i] <= upper:\n        hi += 1\n      self.ans += hi - lo\n\n    sorted = [0] * (r - l + 1)\n    k = 0      # sorted's index\n    i = l      # left's index\n    j = m + 1  # right's index\n\n    while i <= m and j <= r:\n      if prefix[i] < prefix[j]:\n        sorted[k] = prefix[i]\n        k += 1\n        i += 1\n      else:\n        sorted[k] = prefix[j]\n        k += 1\n        j += 1\n\n    # Put possible remaining left part to the sorted array\n    while i <= m:\n      sorted[k] = prefix[i]\n      k += 1\n      i += 1\n\n    # Put possible remaining right part to the sorted array\n    while j <= r:\n      sorted[k] = prefix[j]\n      k += 1\n      j += 1\n\n    prefix[l:l + len(sorted)] = sorted\n"
    }
  ],
  [
    {
      "id": "328. Odd Even Linked List",
      "code": "class Solution:\n  def oddEvenList(self, head: ListNode) -> ListNode:\n    oddHead = ListNode(0)\n    evenHead = ListNode(0)\n    odd = oddHead\n    even = evenHead\n    isOdd = True\n\n    while head:\n      if isOdd:\n        odd.next = head\n        odd = head\n      else:\n        even.next = head\n        even = head\n      head = head.next\n      isOdd = not isOdd\n\n    even.next = None\n    odd.next = evenHead.next\n    return oddHead.next\n"
    }
  ],
  [
    {
      "id": "329. Longest Increasing Path in a Matrix",
      "code": "class Solution:\n  def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\n    m = len(matrix)\n    n = len(matrix[0])\n\n    @functools.lru_cache(None)\n    def dfs(i: int, j: int, prev: int) -> int:\n      if i < 0 or i == m or j < 0 or j == n:\n        return 0\n      if matrix[i][j] <= prev:\n        return 0\n\n      curr = matrix[i][j]\n      return 1 + max(dfs(i + 1, j, curr),\n                     dfs(i - 1, j, curr),\n                     dfs(i, j + 1, curr),\n                     dfs(i, j - 1, curr))\n\n    return max(dfs(i, j, -math.inf) for i in range(m) for j in range(n))\n"
    }
  ],
  [
    {
      "id": "330. Patching Array",
      "code": "class Solution:\n  def minPatches(self, nums: List[int], n: int) -> int:\n    ans = 0\n    i = 0     # Point to nums\n    miss = 1  # Min sum in [1, n] we might miss\n\n    while miss <= n:\n      if i < len(nums) and nums[i] <= miss:\n        miss += nums[i]\n        i += 1\n      else:\n        # Greedily add miss itself to increase the range\n        # From [1, miss) to [1, 2 * miss)\n        miss += miss\n        ans += 1\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "331. Verify Preorder Serialization of a Binary Tree",
      "code": "class Solution:\n  def isValidSerialization(self, preorder: str) -> bool:\n    degree = 1  # OutDegree (children) - inDegree (parent)\n\n    for node in preorder.split(','):\n      degree -= 1\n      if degree < 0:\n        return False\n      if node != '#':\n        degree += 2\n\n    return degree == 0\n"
    }
  ],
  [
    {
      "id": "332. Reconstruct Itinerary",
      "code": "class Solution:\n  def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n    ans = []\n    graph = collections.defaultdict(list)\n\n    for a, b in reversed(sorted(tickets)):\n      graph[a].append(b)\n\n    def dfs(u: str) -> None:\n      while u in graph and graph[u]:\n        dfs(graph[u].pop())\n      ans.append(u)\n\n    dfs('JFK')\n    return ans[::-1]\n"
    }
  ],
  null,
  [
    {
      "id": "334. Increasing Triplet Subsequence",
      "code": "class Solution:\n  def increasingTriplet(self, nums: List[int]) -> bool:\n    first = math.inf\n    second = math.inf\n\n    for num in nums:\n      if num <= first:\n        first = num\n      elif num <= second:  # First < num <= second\n        second = num\n      else:\n        return True  # First < second < num (third)\n\n    return False\n"
    }
  ],
  [
    {
      "id": "335. Self Crossing",
      "code": "class Solution:\n  def isSelfCrossing(self, x: List[int]) -> bool:\n    if len(x) <= 3:\n      return False\n\n    for i in range(3, len(x)):\n      if x[i - 2] <= x[i] and x[i - 1] <= x[i - 3]:\n        return True\n      if i >= 4 and x[i - 1] == x[i - 3] and x[i - 2] <= x[i] + x[i - 4]:\n        return True\n      if i >= 5 and x[i - 4] <= x[i - 2] and x[i - 2] <= x[i] + x[i - 4] and x[i - 1] <= x[i - 3] and x[i - 3] <= x[i - 1] + x[i - 5]:\n        return True\n\n    return False\n"
    }
  ],
  [
    {
      "id": "336. Palindrome Pairs",
      "code": "class Solution:\n  def palindromePairs(self, words: List[str]) -> List[List[int]]:\n    ans = []\n    dict = {word[::-1]: i for i, word in enumerate(words)}\n\n    for i, word in enumerate(words):\n      if \"\" in dict and dict[\"\"] != i and word == word[::-1]:\n        ans.append([i, dict[\"\"]])\n\n      for j in range(1, len(word) + 1):\n        l = word[:j]\n        r = word[j:]\n        if l in dict and dict[l] != i and r == r[::-1]:\n          ans.append([i, dict[l]])\n        if r in dict and dict[r] != i and l == l[::-1]:\n          ans.append([dict[r], i])\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "337. House Robber III",
      "code": "class Solution:\n  def rob(self, root: Optional[TreeNode]) -> int:\n    def robOrNot(root: Optional[TreeNode]) -> tuple:\n      if not root:\n        return (0, 0)\n\n      robLeft, notRobLeft = robOrNot(root.left)\n      robRight, notRobRight = robOrNot(root.right)\n\n      return (root.val + notRobLeft + notRobRight,\n              max(robLeft, notRobLeft) + max(robRight, notRobRight))\n\n    return max(robOrNot(root))\n"
    }
  ],
  [
    {
      "id": "338. Counting Bits",
      "code": "class Solution:\n  def countBits(self, n: int) -> List[int]:\n    # Let f(i) := i's # Of 1's in bitmask\n    # f(i) = f(i / 2) + i % 2\n    ans = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n      ans[i] = ans[i // 2] + (i & 1)\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "339. Nested List Weight Sum",
      "code": "class Solution:\n  def depthSum(self, nestedList: List[NestedInteger]) -> int:\n    ans = 0\n    depth = 0\n    q = collections.deque()\n\n    def addIntegers(nestedList: List[NestedInteger]) -> None:\n      for ni in nestedList:\n        q.append(ni)\n\n    addIntegers(nestedList)\n\n    while q:\n      depth += 1\n      for _ in range(len(q)):\n        ni = q.popleft()\n        if ni.isInteger():\n          ans += ni.getInteger() * depth\n        else:\n          addIntegers(ni.getList())\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "340. Longest Substring with At Most K Distinct Characters",
      "code": "class Solution:\n  def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:\n    ans = 0\n    distinct = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      if count[c] == 1:\n        distinct += 1\n      while distinct == k + 1:\n        count[s[l]] -= 1\n        if count[s[l]] == 0:\n          distinct -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "341. Flatten Nested List Iterator",
      "code": "class NestedIterator:\n  def __init__(self, nestedList: List[NestedInteger]):\n    self.q = collections.deque()\n    self.addInteger(nestedList)\n\n  def next(self) -> int:\n    return self.q.popleft()\n\n  def hasNext(self) -> bool:\n    return self.q\n\n  def addInteger(self, nestedList: List[NestedInteger]) -> None:\n    for ni in nestedList:\n      if ni.isInteger():\n        self.q.append(ni.getInteger())\n      else:\n        self.addInteger(ni.getList())\n"
    }
  ],
  [
    {
      "id": "342. Power of Four",
      "code": "class Solution:\n  def isPowerOfFour(self, n: int) -> bool:\n    # Why (4^n - 1) % 3 == 0?\n    # (4^n - 1) = (2^n - 1)(2^n + 1) and 2^n - 1, 2^n, 2^n + 1 are\n    # Three consecutive numbers among one of them, there must be a multiple\n    # Of 3, and that can't be 2^n, so it must be either 2^n - 1 or 2^n + 1.\n    # Therefore, 4^n - 1 is a multiple of 3.\n    return n > 0 and bin(n).count('1') == 1 and (n - 1) % 3 == 0\n"
    }
  ],
  [
    {
      "id": "343. Integer Break",
      "code": "class Solution:\n  def integerBreak(self, n: int) -> int:\n    if n == 2:\n      return 1\n    if n == 3:\n      return 2\n\n    ans = 1\n\n    while n > 4:\n      n -= 3\n      ans *= 3\n    ans *= n\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "344. Reverse String",
      "code": "class Solution:\n  def reverseString(self, s: List[str]) -> None:\n    l = 0\n    r = len(s) - 1\n\n    while l < r:\n      s[l], s[r] = s[r], s[l]\n      l += 1\n      r -= 1\n"
    }
  ],
  [
    {
      "id": "345. Reverse Vowels of a String",
      "code": "class Solution:\n  def reverseVowels(self, s: str) -> str:\n    charList = list(s)\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    l = 0\n    r = len(s) - 1\n\n    while l < r:\n      while l < r and charList[l] not in vowels:\n        l += 1\n      while l < r and charList[r] not in vowels:\n        r -= 1\n      charList[l], charList[r] = charList[r], charList[l]\n      l += 1\n      r -= 1\n\n    return ''.join(charList)\n"
    }
  ],
  [
    {
      "id": "346. Moving Average from Data Stream",
      "code": "class MovingAverage:\n  def __init__(self, size: int):\n    self.size = size\n    self.sum = 0\n    self.q = collections.deque()\n\n  def next(self, val: int) -> float:\n    if len(self.q) == self.size:\n      self.sum -= self.q.popleft()\n    self.sum += val\n    self.q.append(val)\n    return self.sum / len(self.q)\n"
    }
  ],
  null,
  [
    {
      "id": "348. Design Tic-Tac-Toe",
      "code": "class TicTacToe:\n  def __init__(self, n: int):\n    self.n = n\n    # Record count('X') - count('O')\n    self.rows = [0] * n\n    self.cols = [0] * n\n    self.diag = 0\n    self.antiDiag = 0\n\n  \"\"\" Player {player} makes a move at ({row}, {col}).\n\n      @param row    The row of the board.\n      @param col    The column of the board.\n      @param player The player, can be either 1 or 2.\n      @return The current winning condition, can be either:\n              0: No one wins.\n              1: Player 1 wins.\n              2: Player 2 wins.\n  \"\"\"\n\n  def move(self, row: int, col: int, player: int) -> int:\n    toAdd = 1 if player == 1 else -1\n    target = self.n if player == 1 else -self.n\n\n    if row == col:\n      self.diag += toAdd\n      if self.diag == target:\n        return player\n\n    if row + col == self.n - 1:\n      self.antiDiag += toAdd\n      if self.antiDiag == target:\n        return player\n\n    self.rows[row] += toAdd\n    if self.rows[row] == target:\n      return player\n\n    self.cols[col] += toAdd\n    if self.cols[col] == target:\n      return player\n\n    return 0\n"
    }
  ],
  [
    {
      "id": "349. Intersection of Two Arrays",
      "code": "class Solution:\n  def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\n    ans = []\n    nums1 = set(nums1)\n\n    for num in nums2:\n      if num in nums1:\n        ans.append(num)\n        nums1.remove(num)\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "350. Intersection of Two Arrays II",
      "code": "class Solution:\n  def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n    if len(nums1) > len(nums2):\n      return self.intersect(nums2, nums1)\n\n    ans = []\n    count = collections.Counter(nums1)\n\n    for num in nums2:\n      if count[num] > 0:\n        ans.append(num)\n        count[num] -= 1\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "351. Android Unlock Patterns",
      "code": "class Solution:\n  def numberOfPatterns(self, m: int, n: int) -> int:\n    seen = set()\n    accross = [[0] * 10 for _ in range(10)]\n\n    accross[1][3] = accross[3][1] = 2\n    accross[1][7] = accross[7][1] = 4\n    accross[3][9] = accross[9][3] = 6\n    accross[7][9] = accross[9][7] = 8\n    accross[1][9] = accross[9][1] = accross[2][8] = accross[8][2] = \\\n        accross[3][7] = accross[7][3] = accross[4][6] = accross[6][4] = 5\n\n    def dfs(u: int, depth: int) -> int:\n      if depth > n:\n        return 0\n\n      seen.add(u)\n      ans = 1 if depth >= m else 0\n\n      for v in range(1, 10):\n        if v == u or v in seen:\n          continue\n        accrossed = accross[u][v]\n        if not accrossed or accrossed in seen:\n          ans += dfs(v, depth + 1)\n\n      seen.remove(u)\n      return ans\n\n    # 1, 3, 7, 9 are symmetric\n    # 2, 4, 6, 8 are symmetric\n    return dfs(1, 1) * 4 + dfs(2, 1) * 4 + dfs(5, 1)\n"
    }
  ],
  null,
  [
    {
      "id": "353. Design Snake Game",
      "code": "class SnakeGame:\n  def __init__(self, width: int, height: int, food: List[List[int]]):\n    \"\"\"\n    Initialize your data structure here.\n    @param width - screen width\n    @param height - screen height\n    @param food - A list of food positions\n    E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0].\n    \"\"\"\n    self.width = width\n    self.height = height\n    self.food = food\n    self.score = 0\n    self.k = 0  # food's index\n    self.lookup = set([self.getId(0, 0)])\n    self.body = collections.deque([self.getId(0, 0)])  # snake's body\n\n  def move(self, direction: str) -> int:\n    \"\"\"\n    Moves the snake.\n    @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down\n    @return The game's score after the move. Return -1 if game over.\n    Game over when snake crosses the screen boundary or bites its body.\n    \"\"\"\n    # Old head's position\n    i = self.body[0] // self.width\n    j = self.body[0] % self.width\n\n    # Update head's position and check if out of bound\n    if direction == \"U\":\n      i -= 1\n      if i < 0:\n        return -1\n    if direction == \"L\":\n      j -= 1\n      if j < 0:\n        return -1\n    if direction == \"R\":\n      j += 1\n      if j == self.width:\n        return -1\n    if direction == \"D\":\n      i += 1\n      if i == self.height:\n        return -1\n\n    newHead = self.getId(i, j)\n\n    # Case 1: eat food and increase size by 1\n    if self.k < len(self.food) and i == self.food[self.k][0] and j == self.food[self.k][1]:\n      self.lookup.add(newHead)\n      self.body.appendleft(newHead)\n      self.k += 1\n      self.score += 1\n      return self.score\n\n    # Case 2: new head != old tail and eat body!\n    if newHead != self.body[-1] and newHead in self.lookup:\n      return -1\n\n    # Case 3: normal case\n    # Remove old tail first(important), then add new head\n    # Because new head may be in old tail's position\n    self.lookup.remove(self.body[-1])\n    self.lookup.add(newHead)\n    self.body.pop()\n    self.body.appendleft(newHead)\n\n    return self.score\n\n  def getId(self, i: int, j: int) -> int:\n    return i * self.width + j\n"
    }
  ],
  [
    {
      "id": "354. Russian Doll Envelopes",
      "code": "class Solution:\n  def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    # Same as 300. Longest Increasing Subsequence\n    ans = 0\n    dp = [0] * len(envelopes)\n\n    for _, h in envelopes:\n      l = 0\n      r = ans\n      while l < r:\n        m = (l + r) // 2\n        if dp[m] >= h:\n          r = m\n        else:\n          l = m + 1\n      dp[l] = h\n      if l == ans:\n        ans += 1\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "355. Design Twitter",
      "code": "class Twitter:\n  def __init__(self):\n    self.timer = itertools.count(step=-1)\n    self.tweets = collections.defaultdict(deque)\n    self.followees = collections.defaultdict(set)\n\n  def postTweet(self, userId: int, tweetId: int) -> None:\n    self.tweets[userId].appendleft((next(self.timer), tweetId))\n    if len(self.tweets[userId]) > 10:\n      self.tweets[userId].pop()\n\n  def getNewsFeed(self, userId: int) -> List[int]:\n    tweets = list(heapq.merge(\n        *(self.tweets[followee] for followee in self.followees[userId] | {userId})))\n    return [tweetId for _, tweetId in tweets[:10]]\n\n  def follow(self, followerId: int, followeeId: int) -> None:\n    self.followees[followerId].add(followeeId)\n\n  def unfollow(self, followerId: int, followeeId: int) -> None:\n    self.followees[followerId].discard(followeeId)\n"
    }
  ],
  [
    {
      "id": "356. Line Reflection",
      "code": "class Solution:\n  def isReflected(self, points: List[List[int]]) -> bool:\n    minX = math.inf\n    maxX = -math.inf\n    seen = set()\n\n    for x, y in points:\n      minX = min(minX, x)\n      maxX = max(maxX, x)\n      seen.add((x, y))\n\n    summ = minX + maxX\n    # (leftX + rightX) / 2 = (minX + maxX) / 2\n    #  leftX = minX + maxX - rightX\n    # RightX = minX + maxX - leftX\n\n    return all((summ - x, y) in seen for x, y in points)\n"
    }
  ],
  [
    {
      "id": "357. Count Numbers with Unique Digits",
      "code": "class Solution:\n  def countNumbersWithUniqueDigits(self, n: int) -> int:\n    if n == 0:\n      return 1\n\n    ans = 10\n    uniqueDigits = 9\n    availableNum = 9\n\n    while n > 1 and availableNum > 0:\n      uniqueDigits *= availableNum\n      ans += uniqueDigits\n      n -= 1\n      availableNum -= 1\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "358. Rearrange String k Distance Apart",
      "code": "class Solution:\n  def rearrangeString(self, s: str, k: int) -> str:\n    n = len(s)\n    ans = []\n    count = collections.Counter(s)\n    # valid[i] := the leftmost index i can appear\n    valid = collections.Counter()\n\n    # Returns the letter that has most count and also valid\n    def getBestLetter(index: int) -> chr:\n      maxCount = -1\n      bestLetter = '*'\n\n      for c in string.ascii_lowercase:\n        if count[c] > 0 and count[c] > maxCount and index >= valid[c]:\n          bestLetter = c\n          maxCount = count[c]\n\n      return bestLetter\n\n    for i in range(n):\n      c = getBestLetter(i)\n      if c == '*':\n        return ''\n      ans.append(c)\n      count[c] -= 1\n      valid[c] = i + k\n\n    return ''.join(ans)\n"
    }
  ],
  [
    {
      "id": "359. Logger Rate Limiter",
      "code": "class Logger:\n  def __init__(self):\n    # [(timestamp, message)]\n    self.messageQueue = collections.deque()\n    self.messageSet = set()\n\n  def shouldPrintMessage(self, timestamp: int, message: str) -> bool:\n    # Remove messages that are 10 secs from the current timestamp\n    while self.messageQueue:\n      headTimestamp, headMessage = self.messageQueue[0]\n      if timestamp < headTimestamp + 10:\n        break\n      self.messageQueue.popleft()\n      self.messageSet.remove(headMessage)\n\n    if message in self.messageSet:\n      return False\n\n    self.messageQueue.append((timestamp, message))\n    self.messageSet.add(message)\n    return True\n"
    }
  ],
  [
    {
      "id": "360. Sort Transformed Array",
      "code": "class Solution:\n  def sortTransformedArray(self, nums: List[int], a: int, b: int, c: int) -> List[int]:\n    n = len(nums)\n    upward = a > 0\n    ans = [0] * n\n\n    # The concavity of f only depends on a's sign\n    def f(x: int, a: int, b: int, c: int) -> int:\n      return (a * x + b) * x + c\n\n    quad = [f(num, a, b, c) for num in nums]\n\n    i = n - 1 if upward else 0\n    l = 0\n    r = n - 1\n    while l <= r:\n      if upward:  # Maximum in both ends\n        if quad[l] > quad[r]:\n          ans[i] = quad[l]\n          l += 1\n        else:\n          ans[i] = quad[r]\n          r -= 1\n        i -= 1\n      else:  # Minimum in both ends\n        if quad[l] < quad[r]:\n          ans[i] = quad[l]\n          l += 1\n        else:\n          ans[i] = quad[r]\n          r -= 1\n        i += 1\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "361. Bomb Enemy",
      "code": "class Solution:\n  def maxKilledEnemies(self, grid: List[List[chr]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    enemyCount = 0\n    # dp[i][j] := max enemies grid[i][j] can kill\n    dp = [[0] * n for _ in range(m)]\n\n    def update(i: int, j: int) -> None:\n      nonlocal enemyCount\n      if grid[i][j] == '0':\n        dp[i][j] += enemyCount\n      elif grid[i][j] == 'E':\n        enemyCount += 1\n      else:  # grid[i][j] == 'W'\n        enemyCount = 0\n\n    # Extend four directions, if meet 'W', need to start over from 0\n    for i in range(m):\n      enemyCount = 0\n      for j in range(n):\n        update(i, j)\n      enemyCount = 0\n      for j in reversed(range(n)):\n        update(i, j)\n\n    for j in range(n):\n      enemyCount = 0\n      for i in range(m):\n        update(i, j)\n      enemyCount = 0\n      for i in reversed(range(m)):\n        update(i, j)\n\n    # Returns sum(map(sum, dp))\n    return max(map(max, dp))\n"
    }
  ],
  [
    {
      "id": "362. Design Hit Counter",
      "code": "class HitCounter:\n  def __init__(self):\n    self.timestamps = [0] * 300\n    self.hits = [0] * 300\n\n  def hit(self, timestamp: int) -> None:\n    i = timestamp % 300\n\n    if self.timestamps[i] == timestamp:\n      self.hits[i] += 1\n    else:\n      self.timestamps[i] = timestamp\n      self.hits[i] = 1  # Reset hit count to 1\n\n  def getHits(self, timestamp: int) -> int:\n    return sum(h for t, h in zip(self.timestamps, self.hits) if timestamp - t < 300)\n"
    }
  ],
  null,
  null,
  null,
  null,
  [
    {
      "id": "367. Valid Perfect Square",
      "code": "class Solution:\n  def isPerfectSquare(self, num: int) -> bool:\n    l = 1\n    r = num\n\n    while l < r:\n      m = (l + r) // 2\n      if m >= num / m:\n        r = m\n      else:\n        l = m + 1\n\n    return l * l == num\n"
    }
  ],
  [
    {
      "id": "368. Largest Divisible Subset",
      "code": "class Solution:\n  def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\n    n = len(nums)\n    ans = []\n    count = [1] * n\n    prevIndex = [-1] * n\n    maxCount = 0\n    index = -1\n\n    nums.sort()\n\n    for i, num in enumerate(nums):\n      for j in reversed(range(i)):\n        if num % nums[j] == 0 and count[i] < count[j] + 1:\n          count[i] = count[j] + 1\n          prevIndex[i] = j\n      if count[i] > maxCount:\n        maxCount = count[i]\n        index = i\n\n    while index != -1:\n      ans.append(nums[index])\n      index = prevIndex[index]\n\n    return ans\n"
    }
  ],
  null,
  null,
  [
    {
      "id": "371. Sum of Two Integers",
      "code": "class Solution:\n  def getSum(self, a: int, b: int) -> int:\n    mask = 0xFFFFFFFF\n    kMax = 2000\n\n    while b:\n      a, b = (a ^ b) & mask, ((a & b) << 1) & mask\n\n    return a if a < kMax else ~(a ^ mask)\n"
    }
  ],
  [
    {
      "id": "372. Super Pow",
      "code": "class Solution:\n  def superPow(self, a: int, b: List[int]) -> int:\n    def powMod(x: int, y: int) -> int:\n      pow = 1\n      for _ in range(y):\n        pow = (pow * x) % k\n      return pow\n\n    k = 1337\n    ans = 1\n\n    for i in b:\n      ans = powMod(ans, 10) * powMod(a, i) % k\n\n    return ans\n"
    }
  ],
  null,
  null,
  [
    {
      "id": "375. Guess Number Higher or Lower II",
      "code": "class Solution:\n  def getMoneyAmount(self, n: int) -> int:\n    # dp(i, j) := min money you need to guarantee a win of picking i..j\n    @functools.lru_cache(None)\n    def dp(i: int, j: int) -> int:\n      if i >= j:\n        return 0\n\n      ans = math.inf\n\n      for k in range(i, j + 1):\n        ans = min(ans, max(dp(i, k - 1), dp(k + 1, j)) + k)\n\n      return ans\n\n    return dp(1, n)\n"
    }
  ],
  null,
  [
    {
      "id": "377. Combination Sum IV",
      "code": "class Solution:\n  def combinationSum4(self, nums: List[int], target: int) -> int:\n    dp = [1] + [-1] * target\n\n    def dfs(target: int) -> int:\n      if target < 0:\n        return 0\n      if dp[target] != -1:\n        return dp[target]\n\n      dp[target] = sum(dfs(target - num) for num in nums)\n      return dp[target]\n\n    return dfs(target)\n"
    }
  ],
  [
    {
      "id": "378. Kth Smallest Element in a Sorted Matrix",
      "code": "class Solution:\n  def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\n    minHeap = []  # (matrix[i][j], i, j)\n\n    i = 0\n    while i < k and i < len(matrix):\n      heapq.heappush(minHeap, (matrix[i][0], i, 0))\n      i += 1\n\n    while k > 1:\n      k -= 1\n      _, i, j = heapq.heappop(minHeap)\n      if j + 1 < len(matrix[0]):\n        heapq.heappush(minHeap, (matrix[i][j + 1], i, j + 1))\n\n    return minHeap[0][0]\n"
    }
  ],
  null,
  [
    {
      "id": "380. Insert Delete GetRandom O(1)",
      "code": "class RandomizedSet:\n  def __init__(self):\n    \"\"\"\n    Initialize your data structure here.\n    \"\"\"\n    self.vals = []\n    self.valToIndex = collections.defaultdict(int)\n\n  def insert(self, val: int) -> bool:\n    \"\"\"\n    Inserts a value to the set. Returns true if the set did not already contain the specified element.\n    \"\"\"\n    if val in self.valToIndex:\n      return False\n\n    self.valToIndex[val] = len(self.vals)\n    self.vals.append(val)\n    return True\n\n  def remove(self, val: int) -> bool:\n    \"\"\"\n    Removes a value from the set. Returns true if the set contained the specified element.\n    \"\"\"\n    if val not in self.valToIndex:\n      return False\n\n    index = self.valToIndex[val]\n    self.valToIndex[self.vals[-1]] = index\n    del self.valToIndex[val]\n    self.vals[index] = self.vals[-1]\n    self.vals.pop()\n    return True\n\n  def getRandom(self) -> int:\n    \"\"\"\n    Get a random element from the set.\n    \"\"\"\n    index = random.randint(0, len(self.vals) - 1)\n    return self.vals[index]\n"
    }
  ],
  [
    {
      "id": "381. Insert Delete GetRandom O(1) - Duplicates allowed",
      "code": "class RandomizedCollection:\n  def __init__(self):\n    \"\"\"\n    Initialize your data structure here.\n    \"\"\"\n    self.vals = []\n    self.valToIndices = collections.defaultdict(list)\n\n  def insert(self, val: int) -> bool:\n    \"\"\"\n    Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\n    \"\"\"\n    self.valToIndices[val].append(len(self.vals))\n    self.vals.append([val, len(self.valToIndices[val]) - 1])\n    return len(self.valToIndices[val]) == 1\n\n  def remove(self, val: int) -> bool:\n    \"\"\"\n    Removes a value from the collection. Returns true if the collection contained the specified element.\n    \"\"\"\n    if val not in self.valToIndices or self.valToIndices[val] == []:\n      return False\n\n    index = self.valToIndices[val][-1]\n    self.valToIndices[self.vals[-1][0]][self.vals[-1][1]] = index\n    self.valToIndices[val].pop()\n    self.vals[index] = self.vals[-1]\n    self.vals.pop()\n    return True\n\n  def getRandom(self) -> int:\n    \"\"\"\n    Get a random element from the collection.\n    \"\"\"\n    index = random.randint(0, len(self.vals) - 1)\n    return self.vals[index][0]\n"
    }
  ],
  null,
  [
    {
      "id": "383. Ransom Note",
      "code": "class Solution:\n  def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n    count1 = collections.Counter(ransomNote)\n    count2 = collections.Counter(magazine)\n    return all(count1[c] <= count2[c] for c in string.ascii_lowercase)\n"
    }
  ],
  [
    {
      "id": "384. Shuffle an Array",
      "code": "class Solution:\n  def __init__(self, nums: List[int]):\n    self.nums = nums\n\n  def reset(self) -> List[int]:\n    \"\"\"\n    Resets the array to its original configuration and return it.\n    \"\"\"\n    return self.nums\n\n  def shuffle(self) -> List[int]:\n    \"\"\"\n    Returns a random shuffling of the array.\n    \"\"\"\n    A = self.nums.copy()\n    for i in range(len(A) - 1, 0, -1):\n      j = random.randint(0, i)\n      A[i], A[j] = A[j], A[i]\n    return A\n"
    }
  ],
  [
    {
      "id": "385. Mini Parser",
      "code": "class Solution:\n  def deserialize(self, s: str) -> NestedInteger:\n    if s[0] != '[':\n      return NestedInteger(int(s))\n\n    stack = []\n\n    for i, c in enumerate(s):\n      if c == '[':\n        stack.append(NestedInteger())\n        start = i + 1\n      elif c == ',':\n        if i > start:\n          num = int(s[start:i])\n          stack[-1].add(NestedInteger(num))\n        start = i + 1\n      elif c == ']':\n        popped = stack.pop()\n        if i > start:\n          num = int(s[start:i])\n          popped.add(NestedInteger(num))\n        if stack:\n          stack[-1].add(popped)\n        else:\n          return popped\n        start = i + 1\n"
    }
  ],
  null,
  [
    {
      "id": "387. First Unique Character in a String",
      "code": "class Solution:\n  def firstUniqChar(self, s: str) -> int:\n    count = collections.Counter(s)\n\n    for i, c in enumerate(s):\n      if count[c] == 1:\n        return i\n\n    return -1\n"
    }
  ],
  null,
  [
    {
      "id": "389. Find the Difference",
      "code": "class Solution:\n  def findTheDifference(self, s: str, t: str) -> str:\n    count = collections.Counter(s)\n\n    for i, c in enumerate(t):\n      count[c] -= 1\n      if count[c] == -1:\n        return c\n"
    }
  ],
  null,
  null,
  null,
  null,
  [
    {
      "id": "394. Decode String",
      "code": "class Solution:\n  def decodeString(self, s: str) -> str:\n    stack = []  # (prevStr, repeatCount)\n    currStr = ''\n    currNum = 0\n\n    for c in s:\n      if c.isdigit():\n        currNum = currNum * 10 + int(c)\n      else:\n        if c == '[':\n          stack.append((currStr, currNum))\n          currStr = ''\n          currNum = 0\n        elif c == ']':\n          prevStr, num = stack.pop()\n          currStr = prevStr + num * currStr\n        else:\n          currStr += c\n\n    return currStr\n"
    }
  ],
  null,
  [
    {
      "id": "396. Rotate Function",
      "code": "class Solution:\n  def maxRotateFunction(self, nums: List[int]) -> int:\n    f = sum(i * num for i, num in enumerate(nums))\n    ans = f\n    summ = sum(nums)\n\n    for a in reversed(nums):\n      f += summ - len(nums) * a\n      ans = max(ans, f)\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "397. Integer Replacement",
      "code": "class Solution:\n  def integerReplacement(self, n: int) -> int:\n    ans = 0\n\n    while n > 1:\n      if (n & 1) == 0:\n        n >>= 1\n      elif n == 3 or ((n >> 1) & 1) == 0:\n        n -= 1\n      else:\n        n += 1\n      ans += 1\n\n    return ans\n"
    }
  ],
  null,
  [
    {
      "id": "399. Evaluate Division",
      "code": "class Solution:\n  def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n    ans = []\n    # graph[A][B] := A / B\n    graph = collections.defaultdict(dict)\n\n    for (A, B), value in zip(equations, values):\n      graph[A][B] = value\n      graph[B][A] = 1 / value\n\n    # Returns A / C\n    def devide(A: str, C: str, seen: Set[str]) -> float:\n      if A == C:\n        return 1.0\n\n      seen.add(A)\n\n      # Value := A / B\n      for B, value in graph[A].items():\n        if B in seen:\n          continue\n        res = devide(B, C, seen)  # B / C\n        if res > 0:  # Valid\n          return value * res  # (A / B) * (B / C) = A / C\n\n      return -1.0  # Invalid\n\n    for A, C in queries:\n      if A not in graph and C not in graph:\n        ans.append(-1.0)\n      else:\n        ans.append(devide(A, C, set()))\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "400. Nth Digit",
      "code": "class Solution:\n  def findNthDigit(self, n: int) -> int:\n    def getDigit(num: int, pos: int, digitSize: int):\n      if pos == 0:\n        return num % 10\n      for _ in range(digitSize - pos):\n        num //= 10\n      return num % 10\n\n    digitSize = 1\n    startNum = 1\n    count = 9\n\n    while digitSize * count < n:\n      n -= digitSize * count\n      digitSize += 1\n      startNum *= 10\n      count *= 10\n\n    targetNum = startNum + (n - 1) // digitSize\n    pos = n % digitSize\n\n    return getDigit(targetNum, pos, digitSize)\n"
    }
  ],
  null,
  null,
  [
    {
      "id": "403. Frog Jump",
      "code": "class Solution:\n  def canCross(self, stones: List[int]) -> bool:\n    n = len(stones)\n    # dp[i][j] := True if a frog can make a size j jump to stones[i]\n    dp = [[False] * (n + 1) for _ in range(n)]\n    dp[0][0] = True\n\n    for i in range(1, n):\n      for j in range(i):\n        k = stones[i] - stones[j]\n        if k > n:\n          continue\n        for x in (k - 1, k, k + 1):\n          if 0 <= x <= n:\n            dp[i][k] |= dp[j][x]\n\n    return any(dp[-1])\n"
    }
  ],
  null,
  null,
  null,
  null,
  null,
  [
    {
      "id": "409. Longest Palindrome",
      "code": "class Solution:\n  def longestPalindrome(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter(s)\n\n    for c in count.values():\n      ans += c if c % 2 == 0 else c - 1\n\n    hasOddCount = any(c % 2 == 1 for c in count.values())\n\n    return ans + hasOddCount\n"
    }
  ],
  [
    {
      "id": "410. Split Array Largest Sum",
      "code": "class Solution:\n  def splitArray(self, nums: List[int], m: int) -> int:\n    n = len(nums)\n    prefix = [0] + list(itertools.accumulate(nums))\n\n    # dp(i, k) := min of largest sum to split first i nums into k groups\n    @functools.lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      if k == 1:\n        return prefix[i]\n\n      ans = math.inf\n\n      # Try all possible partitions\n      for j in range(k - 1, i):\n        ans = min(ans, max(dp(j, k - 1), prefix[i] - prefix[j]))\n\n      return ans\n\n    return dp(n, m)\n"
    }
  ],
  [
    {
      "id": "411. Minimum Unique Word Abbreviation",
      "code": "class Solution:\n  def minAbbreviation(self, target: str, dictionary: List[str]) -> str:\n    m = len(target)\n\n    def getMask(word: str) -> int:\n      # mask[i] = 0 := target[i] == word[i]\n      # mask[i] = 1 := target[i] != word[i]\n      # E.g. target = \"apple\"\n      #        word = \"blade\"\n      #        mask =  11110\n      mask = 0\n      for i, c in enumerate(word):\n        if c != target[i]:\n          mask |= 1 << m - 1 - i\n      return mask\n\n    masks = [getMask(word) for word in dictionary if len(word) == m]\n    if not masks:\n      return str(m)\n\n    abbrs = []\n\n    def getAbbr(cand: int) -> str:\n      abbr = ''\n      replacedCount = 0\n      for i, c in enumerate(target):\n        if cand >> m - 1 - i & 1:\n          # cand[i] = 1, abbr should show the original character\n          if replacedCount:\n            abbr += str(replacedCount)\n          abbr += c\n          replacedCount = 0\n        else:\n          # cand[i] = 0, abbr can be replaced\n          replacedCount += 1\n      if replacedCount:\n        abbr += str(replacedCount)\n      return abbr\n\n    # For all candidate representation of target\n    for cand in range(2**m):\n      # All masks have at lease one bit different from candidate\n      if all(cand & mask for mask in masks):\n        abbr = getAbbr(cand)\n        abbrs.append(abbr)\n\n    def getAbbrLen(abbr: str) -> int:\n      abbrLen = 0\n      i = 0\n      j = 0\n      while i < len(abbr):\n        if abbr[j].isalpha():\n          j += 1\n        else:\n          while j < len(abbr) and abbr[j].isdigit():\n            j += 1\n        abbrLen += 1\n        i = j\n      return abbrLen\n\n    return min(abbrs, key=lambda x: getAbbrLen(x))\n"
    }
  ],
  [
    {
      "id": "412. Fizz Buzz",
      "code": "class Solution:\n  def fizzBuzz(self, n: int) -> List[str]:\n    d = {3: 'Fizz', 5: 'Buzz'}\n    return [''.join([d[k] for k in d if i % k == 0]) or str(i) for i in range(1, n + 1)]\n"
    }
  ],
  null,
  null,
  [
    {
      "id": "415. Add Strings",
      "code": "class Solution:\n  def addStrings(self, num1: str, num2: str) -> str:\n    ans = []\n    carry = 0\n    i = len(num1) - 1\n    j = len(num2) - 1\n\n    while i >= 0 or j >= 0 or carry:\n      if i >= 0:\n        carry += int(num1[i])\n      if j >= 0:\n        carry += int(num2[j])\n      ans.append(str(carry % 10))\n      carry //= 10\n      i -= 1\n      j -= 1\n\n    return ''.join(ans[::-1])\n"
    }
  ],
  [
    {
      "id": "416. Partition Equal Subset Sum",
      "code": "class Solution:\n  def canPartition(self, nums: List[int]) -> bool:\n    summ = sum(nums)\n    if summ & 1:\n      return False\n    return self.knapsack_(nums, summ // 2)\n\n  def knapsack_(self, nums: List[int], subsetSum: int) -> bool:\n    n = len(nums)\n    # dp[i][j] := True if j can be formed by nums[0..i)\n    dp = [[False] * (subsetSum + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n      num = nums[i - 1]\n      for j in range(subsetSum + 1):\n        if j < num:\n          dp[i][j] = dp[i - 1][j]\n        else:\n          dp[i][j] = dp[i - 1][j] or dp[i - 1][j - num]\n\n    return dp[n][subsetSum]\n"
    }
  ],
  [
    {
      "id": "417. Pacific Atlantic Water Flow",
      "code": "class Solution:\n  def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n    m = len(heights)\n    n = len(heights[0])\n    dirs = [0, 1, 0, -1, 0]\n    qP = collections.deque()\n    qA = collections.deque()\n    seenP = [[False] * n for _ in range(m)]\n    seenA = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      qP.append((i, 0))\n      qA.append((i, n - 1))\n      seenP[i][0] = True\n      seenA[i][n - 1] = True\n\n    for j in range(n):\n      qP.append((0, j))\n      qA.append((m - 1, j))\n      seenP[0][j] = True\n      seenA[m - 1][j] = True\n\n    def bfs(q: deque, seen: List[List[bool]]):\n      while q:\n        i, j = q.popleft()\n        h = heights[i][j]\n        for k in range(4):\n          x = i + dirs[k]\n          y = j + dirs[k + 1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if seen[x][y] or heights[x][y] < h:\n            continue\n          q.append((x, y))\n          seen[x][y] = True\n\n    bfs(qP, seenP)\n    bfs(qA, seenA)\n\n    return [[i, j] for i in range(m) for j in range(n) if seenP[i][j] and seenA[i][j]]\n"
    }
  ],
  [
    {
      "id": "418. Sentence Screen Fitting",
      "code": "class Solution:\n  def wordsTyping(self, sentence: List[str], rows: int, cols: int) -> int:\n    combined = ' '.join(sentence) + ' '\n    n = len(combined)\n    i = 0\n\n    for _ in range(rows):\n      i += cols\n      if combined[i % n] == ' ':\n        i += 1\n      else:\n        while i > 0 and combined[(i - 1) % n] != ' ':\n          i -= 1\n\n    return i // n\n"
    }
  ],
  null,
  null,
  [
    {
      "id": "421. Maximum XOR of Two Numbers in an Array",
      "code": "class Solution:\n  def findMaximumXOR(self, nums: List[int]) -> int:\n    maxNum = max(nums)\n    if maxNum == 0:\n      return 0\n    maxBit = int(math.log2(maxNum))\n    ans = 0\n    mask = 0\n\n    # If ans is 11100 when i = 2, it means that before we reach the last two\n    # bits, 11100 is the maximum XOR we have, and we're going to explore if we\n    # can get another two '1's and put them into ans.\n    for i in range(maxBit, -1, -1):\n      # Mask grows like: 100...000, 110...000, 111...000, ..., 111...111.\n      mask |= 1 << i\n      # We only care about the left parts,\n      # If i = 2, nums = [1110, 1011, 0111]\n      #    -> prefixes = [1100, 1000, 0100]\n      prefixes = set([num & mask for num in nums])\n      # If i = 1 and before this iteration, the ans is 10100, it means that we\n      # want to grow the ans to 10100 | 1 << 1 = 10110 and we're looking for\n      # XOR of two prefixes = candidate.\n      candidate = ans | 1 << i\n      for prefix in prefixes:\n        if prefix ^ candidate in prefixes:\n          ans = candidate\n          break\n\n    return ans\n"
    }
  ],
  null,
  [
    {
      "id": "423. Reconstruct Original Digits from English",
      "code": "class Solution:\n  def originalDigits(self, s: str) -> str:\n    count = [0] * 10\n\n    for c in s:\n      if c == 'z':\n        count[0] += 1\n      if c == 'o':\n        count[1] += 1\n      if c == 'w':\n        count[2] += 1\n      if c == 'h':\n        count[3] += 1\n      if c == 'u':\n        count[4] += 1\n      if c == 'f':\n        count[5] += 1\n      if c == 'x':\n        count[6] += 1\n      if c == 's':\n        count[7] += 1\n      if c == 'g':\n        count[8] += 1\n      if c == 'i':\n        count[9] += 1\n\n    count[1] -= count[0] + count[2] + count[4]\n    count[3] -= count[8]\n    count[5] -= count[4]\n    count[7] -= count[6]\n    count[9] -= count[5] + count[6] + count[8]\n\n    return ''.join(chr(i + ord('0')) for i, c in enumerate(count) for j in range(c))\n"
    }
  ],
  [
    {
      "id": "424. Longest Repeating Character Replacement",
      "code": "class Solution:\n  def characterReplacement(self, s: str, k: int) -> int:\n    ans = 0\n    maxCount = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      maxCount = max(maxCount, count[c])\n      while maxCount + k < r - l + 1:\n        count[s[l]] -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans\n"
    }
  ],
  null,
  null,
  null,
  null,
  null,
  [
    {
      "id": "430. Flatten a Multilevel Doubly Linked List",
      "code": "class Solution:\n  def flatten(self, head: 'Node') -> 'Node':\n    def flatten(head: 'Node', rest: 'Node') -> 'Node':\n      if not head:\n        return rest\n\n      head.next = flatten(head.child, flatten(head.next, rest))\n      if head.next:\n        head.next.prev = head\n      head.child = None\n      return head\n\n    return flatten(head, None)\n"
    }
  ],
  [
    {
      "id": "431. Encode N-ary Tree to Binary Tree",
      "code": "class Codec:\n  # Encodes an n-ary tree to a binary tree.\n  def encode(self, root: 'Node') -> Optional[TreeNode]:\n    if not root:\n      return None\n\n    rootTreeNode = TreeNode(root.val)\n    q = collections.deque([(root, rootTreeNode)])\n\n    while q:\n      parentNode, parentTreeNode = q.popleft()\n      prevTreeNode = None\n      headTreeNode = None\n      for child in parentNode.children:\n        currTreeNode = TreeNode(child.val)\n        if prevTreeNode:\n          prevTreeNode.right = currTreeNode\n        else:\n          headTreeNode = currTreeNode\n        prevTreeNode = currTreeNode\n        q.append((child, currTreeNode))\n      parentTreeNode.left = headTreeNode\n\n    return rootTreeNode\n\n  # Decodes your binary tree to an n-ary tree.\n  def decode(self, root: Optional[TreeNode]) -> 'Node':\n    if not root:\n      return None\n\n    rootNode = Node(root.val, [])\n    q = collections.deque([(rootNode, root)])\n\n    while q:\n      parentNode, parentTreeNode = q.popleft()\n      sibling = parentTreeNode.left\n      while sibling:\n        currNode = Node(sibling.val, [])\n        parentNode.children.append(currNode)\n        q.append((currNode, sibling))\n        sibling = sibling.right\n\n    return rootNode\n"
    }
  ],
  null,
  null,
  [
    {
      "id": "434. Number of Segments in a String",
      "code": "class Solution:\n  def countSegments(self, s: str) -> int:\n    return len(s.split())\n"
    }
  ],
  [
    {
      "id": "435. Non-overlapping Intervals",
      "code": "class Solution:\n  def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n    ans = 0\n    currentEnd = -math.inf\n\n    for interval in sorted(intervals, key=lambda x: x[1]):\n      if interval[0] >= currentEnd:\n        currentEnd = interval[1]\n      else:\n        ans += 1\n\n    return ans\n"
    }
  ],
  null,
  [
    {
      "id": "437. Path Sum III",
      "code": "class Solution:\n  def pathSum(self, root: TreeNode, summ: int) -> int:\n    if not root:\n      return 0\n\n    def dfs(root: TreeNode, summ: int) -> int:\n      if not root:\n        return 0\n      return (summ == root.val) + \\\n          dfs(root.left, summ - root.val) + \\\n          dfs(root.right, summ - root.val)\n\n    return dfs(root, summ) + \\\n        self.pathSum(root.left, summ) + \\\n        self.pathSum(root.right, summ)\n"
    }
  ],
  [
    {
      "id": "438. Find All Anagrams in a String",
      "code": "class Solution:\n  def findAnagrams(self, s: str, p: str) -> List[int]:\n    ans = []\n    count = collections.Counter(p)\n    required = len(p)\n\n    for r, c in enumerate(s):\n      count[c] -= 1\n      if count[c] >= 0:\n        required -= 1\n      if r >= len(p):\n        count[s[r - len(p)]] += 1\n        if count[s[r - len(p)]] > 0:\n          required += 1\n      if required == 0:\n        ans.append(r - len(p) + 1)\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "439. Ternary Expression Parser",
      "code": "class Solution:\n  def parseTernary(self, expression: str) -> str:\n    c = expression[self.i]\n\n    if self.i + 1 == len(expression) or expression[self.i + 1] == ':':\n      self.i += 2\n      return str(c)\n\n    self.i += 2\n    first = self.parseTernary(expression)\n    second = self.parseTernary(expression)\n\n    return first if c == 'T' else second\n\n  i = 0\n"
    }
  ],
  null,
  [
    {
      "id": "441. Arranging Coins",
      "code": "class Solution:\n  def arrangeCoins(self, n: int) -> int:\n    return int((-1 + sqrt(8 * n + 1)) // 2)\n"
    }
  ],
  [
    {
      "id": "442. Find All Duplicates in an Array",
      "code": "class Solution:\n  def findDuplicates(self, nums: List[int]) -> List[int]:\n    ans = []\n\n    for num in nums:\n      nums[abs(num) - 1] *= -1\n      if nums[abs(num) - 1] > 0:\n        ans.append(abs(num))\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "443. String Compression",
      "code": "class Solution:\n  def compress(self, chars: List[str]) -> int:\n    ans = 0\n    i = 0\n\n    while i < len(chars):\n      letter = chars[i]\n      count = 0\n      while i < len(chars) and chars[i] == letter:\n        count += 1\n        i += 1\n      chars[ans] = letter\n      ans += 1\n      if count > 1:\n        for c in str(count):\n          chars[ans] = c\n          ans += 1\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "444. Sequence Reconstruction",
      "code": "class Solution:\n  def sequenceReconstruction(self, org: List[int], seqs: List[List[int]]) -> bool:\n    if not seqs:\n      return False\n\n    n = len(org)\n    graph = [[] for _ in range(n)]\n    inDegree = [0] * n\n\n    # Build graph\n    for seq in seqs:\n      if len(seq) == 1 and seq[0] < 1 or seq[0] > n:\n        return False\n      else:\n        for u, v in zip(seq, seq[1:]):\n          if u < 1 or u > n or v < 1 or v > n:\n            return False\n          graph[u - 1].append(v - 1)\n          inDegree[v - 1] += 1\n\n    # Topology\n    q = collections.deque([i for i, d in enumerate(inDegree) if d == 0])\n    i = 0  # org's index\n\n    while q:\n      if len(q) > 1:\n        return False\n      u = q.popleft()\n      if u != org[i] - 1:\n        return False\n      i += 1\n      for v in graph[u]:\n        inDegree[v] -= 1\n        if inDegree[v] == 0:\n          q.append(v)\n\n    return i == n\n"
    }
  ],
  [
    {
      "id": "445. Add Two Numbers II",
      "code": "class Solution:\n  def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n    stack1 = []\n    stack2 = []\n\n    while l1:\n      stack1.append(l1)\n      l1 = l1.next\n\n    while l2:\n      stack2.append(l2)\n      l2 = l2.next\n\n    head = None\n    carry = 0\n\n    while carry or stack1 or stack2:\n      if stack1:\n        carry += stack1.pop().val\n      if stack2:\n        carry += stack2.pop().val\n      node = ListNode(carry % 10)\n      node.next = head\n      head = node\n      carry //= 10\n\n    return head\n"
    }
  ],
  null,
  [
    {
      "id": "447. Number of Boomerangs",
      "code": "class Solution:\n  def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n    ans = 0\n\n    for x1, y1 in points:\n      count = collections.defaultdict(int)\n      for x2, y2 in points:\n        ans += 2 * count[(x1 - x2)**2 + (y1 - y2)**2]\n        count[(x1 - x2)**2 + (y1 - y2)**2] += 1\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "448. Find All Numbers Disappeared in an Array",
      "code": "class Solution:\n  def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\n    for num in nums:\n      index = abs(num) - 1\n      nums[index] = -abs(nums[index])\n\n    return [i + 1 for i, num in enumerate(nums) if num > 0]\n"
    }
  ],
  null,
  [
    {
      "id": "450. Delete Node in a BST",
      "code": "class Solution:\n  def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\n    if not root:\n      return None\n    if root.val == key:\n      if not root.left:\n        return root.right\n      if not root.right:\n        return root.left\n      minNode = self._getMin(root.right)\n      root.right = self.deleteNode(root.right, minNode.val)\n      minNode.left = root.left\n      minNode.right = root.right\n      root = minNode\n    elif root.val < key:\n      root.right = self.deleteNode(root.right, key)\n    else:  # Root.val > key\n      root.left = self.deleteNode(root.left, key)\n    return root\n\n  def _getMin(self, node: Optional[TreeNode]) -> Optional[TreeNode]:\n    while node.left:\n      node = node.left\n    return node\n"
    }
  ],
  [
    {
      "id": "451. Sort Characters By Frequency",
      "code": "class Solution:\n  def frequencySort(self, s: str) -> str:\n    ans = []\n    bucket = [[] for _ in range(len(s) + 1)]\n\n    for c, freq in collections.Counter(s).items():\n      bucket[freq].append(c)\n\n    for freq in reversed(range(len(bucket))):\n      for c in bucket[freq]:\n        ans.append(c * freq)\n\n    return ''.join(ans)\n"
    }
  ],
  [
    {
      "id": "452. Minimum Number of Arrows to Burst Balloons",
      "code": "class Solution:\n  def findMinArrowShots(self, points: List[List[int]]) -> int:\n    ans = 0\n    arrowX = -math.inf\n\n    for point in sorted(points, key=lambda x: x[1]):\n      if point[0] > arrowX:\n        ans += 1\n        arrowX = point[1]\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "453. Minimum Moves to Equal Array Elements",
      "code": "class Solution:\n  def minMoves(self, nums: List[int]) -> int:\n    mini = min(nums)\n    return sum(num - mini for num in nums)\n"
    }
  ],
  [
    {
      "id": "454. 4Sum II",
      "code": "class Solution:\n  def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\n    count = collections.Counter(a + b for a in nums1 for b in nums2)\n    return sum(count[-c - d] for c in nums3 for d in nums4)\n"
    }
  ],
  null,
  null,
  [
    {
      "id": "457. Circular Array Loop",
      "code": "class Solution:\n  def circularArrayLoop(self, nums: List[int]) -> bool:\n    def advance(i: int) -> int:\n      return (i + nums[i]) % len(nums)\n\n    if len(nums) < 2:\n      return False\n\n    for i, num in enumerate(nums):\n      if num == 0:\n        continue\n\n      slow = i\n      fast = advance(slow)\n      while num * nums[fast] > 0 and num * nums[advance(fast)] > 0:\n        if slow == fast:\n          if slow == advance(slow):\n            break\n          return True\n        slow = advance(slow)\n        fast = advance(advance(fast))\n\n      slow = i\n      sign = num\n      while sign * nums[slow] > 0:\n        next = advance(slow)\n        nums[slow] = 0\n        slow = next\n\n    return False\n"
    }
  ],
  [
    {
      "id": "458. Poor Pigs",
      "code": "class Solution:\n  def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\n    return math.ceil(log(buckets) / log(minutesToTest // minutesToDie + 1))\n"
    }
  ],
  [
    {
      "id": "459. Repeated Substring Pattern",
      "code": "class Solution:\n  def repeatedSubstringPattern(self, s: str) -> bool:\n    return s in (s + s)[1:-1]\n"
    }
  ],
  null,
  null,
  [
    {
      "id": "462. Minimum Moves to Equal Array Elements II",
      "code": "import statistics\n\n\n class Solution:\n  def minMoves2(self, nums: List[int]) -> int:\n    median = int(statistics.median(nums))\n    return sum(abs(num - median) for num in nums)\n"
    }
  ],
  [
    {
      "id": "463. Island Perimeter",
      "code": "class Solution:\n  def islandPerimeter(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    islands = 0\n    neighbors = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          islands += 1\n          if i + 1 < m and grid[i + 1][j] == 1:\n            neighbors += 1\n          if j + 1 < n and grid[i][j + 1] == 1:\n            neighbors += 1\n\n    return islands * 4 - neighbors * 2\n"
    }
  ],
  null,
  [
    {
      "id": "465. Optimal Account Balancing",
      "code": "class Solution:\n  def minTransfers(self, transactions: List[List[int]]) -> int:\n    balance = [0] * 21\n\n    for u, v, amount in transactions:\n      balance[u] -= amount\n      balance[v] += amount\n\n    debt = [b for b in balance if b]\n\n    def dfs(s: int) -> int:\n      while s < len(debt) and not debt[s]:\n        s += 1\n      if s == len(debt):\n        return 0\n\n      ans = math.inf\n\n      for i in range(s + 1, len(debt)):\n        if debt[i] * debt[s] < 0:\n          debt[i] += debt[s]  # debt[s] is settled\n          ans = min(ans, 1 + dfs(s + 1))\n          debt[i] -= debt[s]  # Backtrack\n\n      return ans\n\n    return dfs(0)\n"
    }
  ],
  null,
  null,
  null,
  [
    {
      "id": "469. Convex Polygon",
      "code": "class Solution:\n  def isConvex(self, points: List[List[int]]) -> bool:\n    # Pq x qr\n    def getCross(p: List[int], q: List[int], r: List[int]):\n      return (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n\n    sign = 0\n    for i in range(len(points)):\n      cross = getCross(points[i - 2], points[i - 1], points[i])\n      if cross == 0:  # P, q, r are collinear\n        continue\n      if sign == 0:  # Find first cross that's not 0\n        sign = cross\n      elif cross * sign < 0:\n        return False\n\n    return True\n"
    }
  ],
  null,
  null,
  [
    {
      "id": "472. Concatenated Words",
      "code": "class Solution:\n  def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n    wordSet = set(words)\n\n    @functools.lru_cache(None)\n    def isConcat(word: str) -> bool:\n      for i in range(1, len(word)):\n        prefix = word[:i]\n        suffix = word[i:]\n        if prefix in wordSet and (suffix in wordSet or isConcat(suffix)):\n          return True\n\n      return False\n\n    return [word for word in words if isConcat(word)]\n"
    }
  ],
  [
    {
      "id": "473. Matchsticks to Square",
      "code": "class Solution:\n  def makesquare(self, matchsticks: List[int]) -> bool:\n    if len(matchsticks) < 4:\n      return False\n\n    perimeter = sum(matchsticks)\n    if perimeter % 4 != 0:\n      return False\n\n    A = sorted(matchsticks)[::-1]\n\n    def dfs(selected: int, edges: List[int]) -> bool:\n      if selected == len(A):\n        return all(edge == edges[0] for edge in edges)\n\n      for i, edge in enumerate(edges):\n        if A[selected] > edge:\n          continue\n        edges[i] -= A[selected]\n        if dfs(selected + 1, edges):\n          return True\n        edges[i] += A[selected]\n\n      return False\n\n    return dfs(0, [perimeter // 4] * 4)\n"
    }
  ],
  [
    {
      "id": "474. Ones and Zeroes",
      "code": "class Solution:\n  def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\n    # dp[i][j] := max size of the subset given i 0's and j 1's are available\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for s in strs:\n      count0 = s.count('0')\n      count1 = len(s) - count0\n      for i in range(m, count0 - 1, -1):\n        for j in range(n, count1 - 1, -1):\n          dp[i][j] = max(dp[i][j], dp[i - count0][j - count1] + 1)\n\n    return dp[m][n]\n"
    }
  ],
  null,
  null,
  null,
  [
    {
      "id": "478. Generate Random Point in a Circle",
      "code": "class Solution:\n  def __init__(self, radius: float, x_center: float, y_center: float):\n    self.radius = radius\n    self.x_center = x_center\n    self.y_center = y_center\n\n  def randPoint(self) -> List[float]:\n    length = sqrt(random.uniform(0, 1)) * self.radius\n    degree = random.uniform(0, 1) * 2 * math.pi\n    x = self.x_center + length * math.cos(degree)\n    y = self.y_center + length * math.sin(degree)\n    return [x, y]\n"
    }
  ],
  [
    {
      "id": "479. Largest Palindrome Product",
      "code": "class Solution:\n  def largestPalindrome(self, n: int) -> int:\n    if n == 1:\n      return 9\n\n    kMod = 1337\n    upper = pow(10, n) - 1\n    lower = pow(10, n - 1) - 1\n\n    for i in range(upper, lower, -1):\n      cand = int(str(i) + str(i)[::-1])\n      j = upper\n      while j * j >= cand:\n        if cand % j == 0:\n          return cand % kMod\n        j -= 1\n"
    }
  ],
  null,
  null,
  [
    {
      "id": "482. License Key Formatting",
      "code": "class Solution:\n  def licenseKeyFormatting(self, s: str, k: int) -> str:\n    ans = []\n    length = 0\n\n    for i in reversed(range(len(s))):\n      if s[i] == '-':\n        continue\n      if length > 0 and length % k == 0:\n        ans += '-'\n      ans += s[i].upper()\n      length += 1\n\n    return ''.join(ans[::-1])\n"
    }
  ],
  [
    {
      "id": "483. Smallest Good Base",
      "code": "class Solution:\n  def smallestGoodBase(self, n: str) -> str:\n    n = int(n)\n\n    for m in range(int(math.log(n, 2)), 1, -1):\n      k = int(n**m**-1)\n      if (k**(m + 1) - 1) // (k - 1) == n:\n        return str(k)\n\n    return str(n - 1)\n"
    }
  ],
  [
    {
      "id": "484. Find Permutation",
      "code": "class Solution:\n  def findPermutation(self, s: str) -> List[int]:\n    ans = []\n    stack = []\n\n    for i, c in enumerate(s):\n      stack.append(i + 1)\n      if c == 'I':\n        while stack:  # Consume all decreasings\n          ans.append(stack.pop())\n    stack.append(len(s) + 1)\n\n    while stack:\n      ans.append(stack.pop())\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "485. Max Consecutive Ones",
      "code": "class Solution:\n  def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\n    ans = 0\n    summ = 0\n\n    for num in nums:\n      if num == 0:\n        summ = 0\n      else:\n        summ += num\n        ans = max(ans, summ)\n\n    return ans\n"
    }
  ],
  null,
  [
    {
      "id": "487. Max Consecutive Ones II",
      "code": "class Solution:\n  def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\n    ans = 0\n    zeros = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      if num == 0:\n        zeros += 1\n      while zeros == 2:\n        if nums[l] == 0:\n          zeros -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans\n"
    }
  ],
  [
    {
      "id": "488. Zuma Game",
      "code": "class Solution:\n  def findMinStep(self, board: str, hand: str) -> int:\n    def deDup(board):\n      start = 0  # Start index of a color sequenece\n      for i, c in enumerate(board):\n        if c != board[start]:\n          if i - start >= 3:\n            return deDup(board[:start] + board[i:])\n          start = i  # Meet a new sequence\n      return board\n\n    @functools.lru_cache(None)\n    def dfs(board: str, hand: str):\n      board = deDup(board)\n      if board == '#':\n        return 0\n\n      boardSet = set(board)\n      # Hand that in board\n      hand = ''.join(h for h in hand if h in boardSet)\n      if not hand:  # Infeasible\n        return math.inf\n\n      ans = math.inf\n\n      for i in range(len(board)):\n        for j, h in enumerate(hand):\n          # Place hs[j] in board[i]\n          newHand = hand[:j] + hand[j + 1:]\n          newBoard = board[:i] + h + board[i:]\n          ans = min(ans, 1 + dfs(newBoard, newHand))\n\n      return ans\n\n    ans = dfs(board + '#', hand)\n    if ans == math.inf\n    return -1\n    else ans\n"
    }
  ],
  null,
  [
    {
      "id": "490. The Maze",
      "code": "class Solution:\n  def hasPath(self, maze: List[List[int]], start: List[int], destination: List[int]) -> bool:\n    m = len(maze)\n    n = len(maze[0])\n    dirs = [0, 1, 0, -1, 0]\n    q = collections.deque([(start[0], start[1])])\n    seen = {(start[0], start[1])}\n\n    def isValid(x: int, y: int) -> bool:\n      return 0 <= x < m and 0 <= y < n and maze[x][y] == 0\n\n    while q:\n      i, j = q.popleft()\n      for k in range(4):\n        x = i\n        y = j\n        while isValid(x + dirs[k], y + dirs[k + 1]):\n          x += dirs[k]\n          y += dirs[k + 1]\n        if [x, y] == destination:\n          return True\n        if (x, y) in seen:\n          continue\n        q.append((x, y))\n        seen.add((x, y))\n\n    return False\n"
    }
  ],
  [
    {
      "id": "491. Non-decreasing Subsequences",
      "code": "class Solution:\n  def findSubsequences(self, nums: List[int]) -> List[List[int]]:\n    ans = []\n\n    def dfs(s: int, path: List[int]) -> None:\n      if len(path) > 1:\n        ans.append(path)\n\n      used = set()\n\n      for i in range(s, len(nums)):\n        if nums[i] in used:\n          continue\n        if not path or nums[i] >= path[-1]:\n          used.add(nums[i])\n          dfs(i + 1, path + [nums[i]])\n\n    dfs(0, [])\n    return ans\n"
    }
  ],
  null,
  null,
  [
    {
      "id": "494. Target Sum",
      "code": "class Solution:\n  def findTargetSumWays(self, nums: List[int], target: int) -> int:\n    summ = sum(nums)\n    if summ < abs(target) or (summ + target) & 1:\n      return 0\n\n    def knapsack(target: int) -> int:\n      # dp[i] := # Of ways to sum to i by nums so far\n      dp = [1] + [0] * summ\n\n      for num in nums:\n        for j in range(summ, num - 1, -1):\n          dp[j] += dp[j - num]\n\n      return dp[target]\n\n    return knapsack((summ + target) // 2)\n"
    }
  ],
  [
    {
      "id": "495. Teemo Attacking",
      "code": "class Solution:\n  def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:\n    if duration == 0:\n      return 0\n\n    ans = 0\n\n    for i in range(0, len(timeSeries) - 1):\n      ans += min(timeSeries[i + 1] - timeSeries[i], duration)\n\n    return ans + duration\n"
    }
  ],
  [
    {
      "id": "496. Next Greater Element I",
      "code": "class Solution:\n  def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n    numToNextGreater = {}\n    stack = []\n\n    for num in nums2:\n      while stack and stack[-1] < num:\n        numToNextGreater[stack.pop()] = num\n      stack.append(num)\n\n    return [numToNextGreater.get(num, -1) for num in nums1]\n"
    }
  ],
  [
    {
      "id": "497. Random Point in Non-overlapping Rectangles",
      "code": "class Solution:\n  def __init__(self, rects: List[List[int]]):\n    self.rects = rects\n    self.areas = list(itertools.accumulate(\n        [(x2 - x1 + 1) * (y2 - y1 + 1) for x1, y1, x2, y2 in rects]))\n\n  def pick(self) -> List[int]:\n    index = bisect_right(self.areas, random.randint(0, self.areas[-1] - 1))\n    x1, y1, x2, y2 = self.rects[index]\n    return [random.randint(x1, x2), random.randint(y1, y2)]\n"
    }
  ],
  null,
  [
    {
      "id": "499. The Maze III",
      "code": "class Solution:\n  def findShortestWay(self, maze: List[List[int]], ball: List[int], hole: List[int]) -> str:\n    ans = \"impossible\"\n    minSteps = math.inf\n\n    def dfs(i: int, j: int, dx: int, dy: int, steps: int, path: str):\n      nonlocal ans\n      nonlocal minSteps\n      if steps >= minSteps:\n        return\n\n      if dx != 0 or dy != 0:  # Both are zero for the initial ball position\n        while 0 <= i + dx < len(maze) and 0 <= j + dy < len(maze[0]) \\\n                and maze[i + dx][j + dy] != 1:\n          i += dx\n          j += dy\n          steps += 1\n          if i == hole[0] and j == hole[1] and steps < minSteps:\n            minSteps = steps\n            ans = path\n\n      if maze[i][j] == 0 or steps + 2 < maze[i][j]:\n        maze[i][j] = steps + 2  # +2 to because of maze[i][j] == 0 || 1\n        if dx == 0:\n          dfs(i, j, 1, 0, steps, path + 'd')\n        if dy == 0:\n          dfs(i, j, 0, -1, steps, path + 'l')\n        if dy == 0:\n          dfs(i, j, 0, 1, steps, path + 'r')\n        if dx == 0:\n          dfs(i, j, -1, 0, steps, path + 'u')\n\n    dfs(ball[0], ball[1], 0, 0, 0, '')\n    return ans\n"
    }
  ]
]
